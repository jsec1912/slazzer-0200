[{"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\App.js":"1","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\index.js":"2","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\ImageEditorWrapper.js":"3","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\ImageEditor.js":"4","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\config.js":"5","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Modal.js":"6","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\is-server-side.js":"7","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\assets\\theme\\light.js":"8","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\assets\\theme\\dark.js":"9","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\index.js":"10","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\assets\\i18n\\index.js":"11","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\index.js":"12","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\CloseBtn.js":"13","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\styleUtils.js":"14","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\index.js":"15","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Toolbar.ui.js":"16","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\ImageEditor.ui.js":"17","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Preview.ui.js":"18","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Footer.ui.js":"19","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Resize.ui.js":"20","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Header.ui.js":"21","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Orientation.ui.js":"22","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Adjust.ui.js":"23","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Common.ui.js":"24","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Button.js":"25","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\CloseBtn.js":"26","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Watermark.ui.js":"27","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Crop.ui.js":"28","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Spinner.js":"29","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\assets\\i18n\\en.js":"30","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\assets\\i18n\\zh-cn.js":"31","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\assets\\i18n\\fr.js":"32","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\index.js":"33","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Footer\\Footer.js":"34","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Preview\\Preview.js":"35","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Toolbar.js":"36","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\PreResize\\PreResize.js":"37","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Tool.js":"38","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Header\\Header.js":"39","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\b64-to-blob.js":"40","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\deep-copy.js":"41","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\adjust-api.js":"42","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-base-api.js":"43","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-base-url.js":"44","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-canvas-node.js":"45","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-effect-handler-name.js":"46","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-icon.js":"47","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-label.js":"48","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-watermark-position.js":"49","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-inner-box-size.js":"50","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-image-sealing-params.js":"51","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\round-decimal-point.js":"52","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-secret-header-name.js":"53","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\convert.js":"54","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\calculate.js":"55","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\layer.js":"56","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\filter.js":"57","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\pixel.js":"58","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\event.js":"59","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\io.js":"60","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\plugin.js":"61","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\lib\\blenders.js":"62","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\lib\\filters.js":"63","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\rotate.js":"64","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\flip.js":"65","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\lib\\size.js":"66","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\stackBlur.js":"67","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\common\\posterize.js":"68","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\common\\vignette.js":"69","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\common\\blur.js":"70","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\effects\\edges.js":"71","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\effects\\grungy.js":"72","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\effects\\hazyDays.js":"73","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\effects\\lomo.js":"74","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\effects\\compoundBlur.js":"75","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\filters\\crossProcess.js":"76","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\effects\\sinCity.js":"77","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\filters\\glowingSun.js":"78","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\filters\\love.js":"79","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\filters\\oldBoot.js":"80","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\filters\\jarques.js":"81","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\filters\\orangePeel.js":"82","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\filters\\pinhole.js":"83","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\filters\\sunrise.js":"84","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\filters\\vintage.js":"85","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\full-screen-handle.js":"86","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\CustomizedCanvas.js":"87","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Preview\\ImageManipulator.js":"88","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Preview\\FocusPointPreview.js":"89","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Filters.js":"90","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Orientation.js":"91","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Effects.js":"92","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Crop.js":"93","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Resize.js":"94","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Adjust.js":"95","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Watermark.js":"96","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\FocusPoint.js":"97","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Text.js":"98","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Shapes.js":"99","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Image.js":"100","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\index.js":"101","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\logger.js":"102","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\blander.js":"103","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\util.js":"104","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\canvas-round.js":"105","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\map-number-range.js":"106","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Effect.js":"107","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Filter.js":"108","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Range.js":"109","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Shapes.ui.js":"110","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Shared\\Select.js":"111","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\module.js":"112","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\store.js":"113","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\renderer.js":"114"},{"size":761,"mtime":1611646488700,"results":"115","hashOfConfig":"116"},{"size":178,"mtime":1611646488700,"results":"117","hashOfConfig":"116"},{"size":4427,"mtime":1609859998000,"results":"118","hashOfConfig":"116"},{"size":13728,"mtime":1609859998000,"results":"119","hashOfConfig":"116"},{"size":6514,"mtime":1609859998000,"results":"120","hashOfConfig":"116"},{"size":4750,"mtime":1609859998000,"results":"121","hashOfConfig":"116"},{"size":111,"mtime":1609859998000,"results":"122","hashOfConfig":"116"},{"size":407,"mtime":1609859998000,"results":"123","hashOfConfig":"116"},{"size":406,"mtime":1609859998000,"results":"124","hashOfConfig":"116"},{"size":412,"mtime":1609859998000,"results":"125","hashOfConfig":"116"},{"size":127,"mtime":1609859998000,"results":"126","hashOfConfig":"116"},{"size":331,"mtime":1609859998000,"results":"127","hashOfConfig":"116"},{"size":921,"mtime":1609859998000,"results":"128","hashOfConfig":"116"},{"size":10356,"mtime":1611650071932,"results":"129","hashOfConfig":"116"},{"size":494,"mtime":1609859998000,"results":"130","hashOfConfig":"116"},{"size":2522,"mtime":1609859998000,"results":"131","hashOfConfig":"116"},{"size":8861,"mtime":1609859998000,"results":"132","hashOfConfig":"116"},{"size":3360,"mtime":1609859998000,"results":"133","hashOfConfig":"116"},{"size":4071,"mtime":1609859998000,"results":"134","hashOfConfig":"116"},{"size":1765,"mtime":1609859998000,"results":"135","hashOfConfig":"116"},{"size":1595,"mtime":1609859998000,"results":"136","hashOfConfig":"116"},{"size":2075,"mtime":1609859998000,"results":"137","hashOfConfig":"116"},{"size":475,"mtime":1609859998000,"results":"138","hashOfConfig":"116"},{"size":348,"mtime":1609859998000,"results":"139","hashOfConfig":"116"},{"size":10255,"mtime":1609859998000,"results":"140","hashOfConfig":"116"},{"size":1325,"mtime":1609859998000,"results":"141","hashOfConfig":"116"},{"size":5177,"mtime":1609859998000,"results":"142","hashOfConfig":"116"},{"size":4419,"mtime":1609859998000,"results":"143","hashOfConfig":"116"},{"size":3878,"mtime":1609859998000,"results":"144","hashOfConfig":"116"},{"size":1840,"mtime":1609859998000,"results":"145","hashOfConfig":"116"},{"size":1964,"mtime":1609859998000,"results":"146","hashOfConfig":"116"},{"size":2060,"mtime":1609859998000,"results":"147","hashOfConfig":"116"},{"size":1332,"mtime":1609859998000,"results":"148","hashOfConfig":"116"},{"size":2535,"mtime":1609859998000,"results":"149","hashOfConfig":"116"},{"size":1769,"mtime":1609859998000,"results":"150","hashOfConfig":"116"},{"size":1659,"mtime":1609859998000,"results":"151","hashOfConfig":"116"},{"size":3796,"mtime":1609859998000,"results":"152","hashOfConfig":"116"},{"size":566,"mtime":1609859998000,"results":"153","hashOfConfig":"116"},{"size":2232,"mtime":1609859998000,"results":"154","hashOfConfig":"116"},{"size":1073,"mtime":1609859998000,"results":"155","hashOfConfig":"116"},{"size":69,"mtime":1609859998000,"results":"156","hashOfConfig":"116"},{"size":443,"mtime":1609859998000,"results":"157","hashOfConfig":"116"},{"size":155,"mtime":1609859998000,"results":"158","hashOfConfig":"116"},{"size":187,"mtime":1609859998000,"results":"159","hashOfConfig":"116"},{"size":256,"mtime":1609859998000,"results":"160","hashOfConfig":"116"},{"size":1302,"mtime":1609859998000,"results":"161","hashOfConfig":"116"},{"size":3436,"mtime":1609859998000,"results":"162","hashOfConfig":"116"},{"size":65,"mtime":1609859998000,"results":"163","hashOfConfig":"116"},{"size":1507,"mtime":1609859998000,"results":"164","hashOfConfig":"116"},{"size":1256,"mtime":1609859998000,"results":"165","hashOfConfig":"116"},{"size":1775,"mtime":1609859998000,"results":"166","hashOfConfig":"116"},{"size":136,"mtime":1609859998000,"results":"167","hashOfConfig":"116"},{"size":136,"mtime":1609859998000,"results":"168","hashOfConfig":"116"},{"size":11068,"mtime":1609859998000,"results":"169","hashOfConfig":"116"},{"size":9110,"mtime":1609859998000,"results":"170","hashOfConfig":"116"},{"size":5496,"mtime":1609859998000,"results":"171","hashOfConfig":"116"},{"size":779,"mtime":1609859998000,"results":"172","hashOfConfig":"116"},{"size":3720,"mtime":1609859998000,"results":"173","hashOfConfig":"116"},{"size":2500,"mtime":1609859998000,"results":"174","hashOfConfig":"116"},{"size":3022,"mtime":1609859998000,"results":"175","hashOfConfig":"116"},{"size":274,"mtime":1609859998000,"results":"176","hashOfConfig":"116"},{"size":2962,"mtime":1609859998000,"results":"177","hashOfConfig":"116"},{"size":7874,"mtime":1609859998000,"results":"178","hashOfConfig":"116"},{"size":1690,"mtime":1609859998000,"results":"179","hashOfConfig":"116"},{"size":671,"mtime":1609859998000,"results":"180","hashOfConfig":"116"},{"size":1726,"mtime":1609859998000,"results":"181","hashOfConfig":"116"},{"size":9669,"mtime":1609859998000,"results":"182","hashOfConfig":"116"},{"size":446,"mtime":1609859998000,"results":"183","hashOfConfig":"116"},{"size":1199,"mtime":1609859998000,"results":"184","hashOfConfig":"116"},{"size":1374,"mtime":1609859998000,"results":"185","hashOfConfig":"116"},{"size":387,"mtime":1609859998000,"results":"186","hashOfConfig":"116"},{"size":180,"mtime":1609859998000,"results":"187","hashOfConfig":"116"},{"size":1138,"mtime":1609859998000,"results":"188","hashOfConfig":"116"},{"size":338,"mtime":1609859998000,"results":"189","hashOfConfig":"116"},{"size":14892,"mtime":1609859998000,"results":"190","hashOfConfig":"116"},{"size":304,"mtime":1609859998000,"results":"191","hashOfConfig":"116"},{"size":183,"mtime":1609859998000,"results":"192","hashOfConfig":"116"},{"size":583,"mtime":1609859998000,"results":"193","hashOfConfig":"116"},{"size":188,"mtime":1609859998000,"results":"194","hashOfConfig":"116"},{"size":283,"mtime":1609859998000,"results":"195","hashOfConfig":"116"},{"size":359,"mtime":1609859998000,"results":"196","hashOfConfig":"116"},{"size":243,"mtime":1609859998000,"results":"197","hashOfConfig":"116"},{"size":165,"mtime":1609859998000,"results":"198","hashOfConfig":"116"},{"size":288,"mtime":1609859998000,"results":"199","hashOfConfig":"116"},{"size":326,"mtime":1609859998000,"results":"200","hashOfConfig":"116"},{"size":1300,"mtime":1609859998000,"results":"201","hashOfConfig":"116"},{"size":33688,"mtime":1609859998000,"results":"202","hashOfConfig":"116"},{"size":42368,"mtime":1609859998000,"results":"203","hashOfConfig":"116"},{"size":2570,"mtime":1609859998000,"results":"204","hashOfConfig":"116"},{"size":461,"mtime":1609859998000,"results":"205","hashOfConfig":"116"},{"size":6757,"mtime":1609859998000,"results":"206","hashOfConfig":"116"},{"size":599,"mtime":1609859998000,"results":"207","hashOfConfig":"116"},{"size":3850,"mtime":1609859998000,"results":"208","hashOfConfig":"116"},{"size":3113,"mtime":1609859998000,"results":"209","hashOfConfig":"116"},{"size":1319,"mtime":1609859998000,"results":"210","hashOfConfig":"116"},{"size":15428,"mtime":1609859998000,"results":"211","hashOfConfig":"116"},{"size":1521,"mtime":1609859998000,"results":"212","hashOfConfig":"116"},{"size":3715,"mtime":1609859998000,"results":"213","hashOfConfig":"116"},{"size":5728,"mtime":1609859998000,"results":"214","hashOfConfig":"116"},{"size":2478,"mtime":1609859998000,"results":"215","hashOfConfig":"116"},{"size":27256,"mtime":1609859998000,"results":"216","hashOfConfig":"116"},{"size":640,"mtime":1609859998000,"results":"217","hashOfConfig":"116"},{"size":865,"mtime":1609859998000,"results":"218","hashOfConfig":"116"},{"size":1959,"mtime":1609859998000,"results":"219","hashOfConfig":"116"},{"size":1122,"mtime":1609859998000,"results":"220","hashOfConfig":"116"},{"size":170,"mtime":1609859998000,"results":"221","hashOfConfig":"116"},{"size":562,"mtime":1609859998000,"results":"222","hashOfConfig":"116"},{"size":517,"mtime":1609859998000,"results":"223","hashOfConfig":"116"},{"size":2670,"mtime":1609859998000,"results":"224","hashOfConfig":"116"},{"size":4040,"mtime":1609859998000,"results":"225","hashOfConfig":"116"},{"size":6349,"mtime":1609859998000,"results":"226","hashOfConfig":"116"},{"size":1914,"mtime":1609859998000,"results":"227","hashOfConfig":"116"},{"size":612,"mtime":1609859998000,"results":"228","hashOfConfig":"116"},{"size":9610,"mtime":1609859998000,"results":"229","hashOfConfig":"116"},{"filePath":"230","messages":"231","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"232","usedDeprecatedRules":"233"},"cwywzo",{"filePath":"234","messages":"235","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"236","messages":"237","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"238","messages":"239","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"240","usedDeprecatedRules":"233"},{"filePath":"241","messages":"242","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"243","messages":"244","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"245","messages":"246","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"247","messages":"248","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"249","usedDeprecatedRules":"233"},{"filePath":"250","messages":"251","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"252","usedDeprecatedRules":"233"},{"filePath":"253","messages":"254","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"255","messages":"256","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"257","usedDeprecatedRules":"233"},{"filePath":"258","messages":"259","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"260","messages":"261","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"262","messages":"263","errorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"264","messages":"265","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"266","messages":"267","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"268","messages":"269","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"270","messages":"271","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"272","usedDeprecatedRules":"233"},{"filePath":"273","messages":"274","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"275","messages":"276","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"277","messages":"278","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"279","messages":"280","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"281","messages":"282","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"283","messages":"284","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"285","messages":"286","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"287","messages":"288","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"289","messages":"290","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"291","messages":"292","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"293","messages":"294","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"295","messages":"296","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"297","usedDeprecatedRules":"233"},{"filePath":"298","messages":"299","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"300","usedDeprecatedRules":"233"},{"filePath":"301","messages":"302","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"303","usedDeprecatedRules":"233"},{"filePath":"304","messages":"305","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"306","messages":"307","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"308","usedDeprecatedRules":"233"},{"filePath":"309","messages":"310","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"311","usedDeprecatedRules":"233"},{"filePath":"312","messages":"313","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"314","usedDeprecatedRules":"233"},{"filePath":"315","messages":"316","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"317","usedDeprecatedRules":"233"},{"filePath":"318","messages":"319","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"320","usedDeprecatedRules":"233"},{"filePath":"321","messages":"322","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"323","usedDeprecatedRules":"233"},{"filePath":"324","messages":"325","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"326","messages":"327","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"328","messages":"329","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"330","messages":"331","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"332","messages":"333","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"334","messages":"335","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"336","messages":"337","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"338","messages":"339","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"340","messages":"341","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"342","messages":"343","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"344","usedDeprecatedRules":"233"},{"filePath":"345","messages":"346","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"347","messages":"348","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"349","messages":"350","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"351","messages":"352","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"353","messages":"354","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"355","usedDeprecatedRules":"233"},{"filePath":"356","messages":"357","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"358","usedDeprecatedRules":"233"},{"filePath":"359","messages":"360","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"361","messages":"362","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"363","messages":"364","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"365","usedDeprecatedRules":"233"},{"filePath":"366","messages":"367","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"368","messages":"369","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"370","messages":"371","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"372","messages":"373","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"374","messages":"375","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"376","usedDeprecatedRules":"233"},{"filePath":"377","messages":"378","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"379","messages":"380","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"381","messages":"382","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"383","messages":"384","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"385","usedDeprecatedRules":"233"},{"filePath":"386","messages":"387","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"388","messages":"389","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"390","messages":"391","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"392","messages":"393","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"394","messages":"395","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"396","messages":"397","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"398","messages":"399","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"400","messages":"401","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"402","usedDeprecatedRules":"233"},{"filePath":"403","messages":"404","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"405","messages":"406","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"407","messages":"408","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"409","messages":"410","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"411","messages":"412","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"413","messages":"414","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"415","messages":"416","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"417","messages":"418","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"419","messages":"420","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"421","messages":"422","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"423","messages":"424","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"425","messages":"426","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"427","usedDeprecatedRules":"233"},{"filePath":"428","messages":"429","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"430","usedDeprecatedRules":"233"},{"filePath":"431","messages":"432","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"433","messages":"434","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"435","usedDeprecatedRules":"233"},{"filePath":"436","messages":"437","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"438","usedDeprecatedRules":"233"},{"filePath":"439","messages":"440","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"441","usedDeprecatedRules":"233"},{"filePath":"442","messages":"443","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"444","usedDeprecatedRules":"233"},{"filePath":"445","messages":"446","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"447","usedDeprecatedRules":"233"},{"filePath":"448","messages":"449","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"450","usedDeprecatedRules":"233"},{"filePath":"451","messages":"452","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"453","usedDeprecatedRules":"233"},{"filePath":"454","messages":"455","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"456","usedDeprecatedRules":"233"},{"filePath":"457","messages":"458","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"459","messages":"460","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"461","messages":"462","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"463","messages":"464","errorCount":0,"warningCount":31,"fixableErrorCount":0,"fixableWarningCount":0,"source":"465","usedDeprecatedRules":"233"},{"filePath":"466","messages":"467","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"468","usedDeprecatedRules":"233"},{"filePath":"469","messages":"470","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"471","messages":"472","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"473","messages":"474","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"475","messages":"476","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"477","usedDeprecatedRules":"233"},{"filePath":"478","messages":"479","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"480","usedDeprecatedRules":"233"},{"filePath":"481","messages":"482","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"483","usedDeprecatedRules":"233"},{"filePath":"484","messages":"485","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"486","messages":"487","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"488","messages":"489","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"490","messages":"491","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"492","messages":"493","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"233"},{"filePath":"494","messages":"495","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"496"},"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\App.js",["497"],"import './App.css';\nimport React, { useState } from 'react';\nimport ImageEditorWrapper from './ImageEditorWrapper';\n\nfunction App() {\n\n   const src = 'https://cdn.scaleflex.it/demo/stephen-walker-unsplash.jpg';\n  const [show, toggle] = useState(false);\n\n  return (\n    <div>\n      <h1>Filerobot Image Editor</h1>\n\n      <img src={src} onClick={() => { toggle(true) }} alt=\"example image\" style={{ maxWidth: '100%' }}/>\n\n      <ImageEditorWrapper\n        show={show}\n        src={src}\n        onClose={() => { toggle(false) }}\n        onOpen={() => console.log('Editor is opened.')}\n        onComplete={(props) => { console.log(props) }}\n        onBeforeComplete={(props) => { console.log(props); return false; }}\n      />\n    </div>\n  );\n}\n\nexport default App;\n",["498","499"],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\index.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\ImageEditorWrapper.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\ImageEditor.js",["500","501"],"import React, { Component } from 'react';\nimport { PreviewWrapper, Spinner, Wrapper } from './styledComponents/index';\nimport { Footer, Header, PreResize, Preview } from './components/index';\nimport imageType from 'image-type';\nimport './lib/caman';\nimport { DEFAULT_WATERMARK, ON_CLOSE_STATUSES } from './config';\nimport { getCanvasNode } from './utils';\n\n\nconst INITIAL_PARAMS = {\n  effect: null,\n  filter: null,\n  crop: null,\n  resize: null,\n  rotate: null,\n  correctionDegree: 0,\n  flipX: false,\n  flipY: false,\n  adjust: {\n    brightness: 0,\n    contrast: 0,\n    saturation: 0,\n    exposure: 0\n  },\n  canvasDimensions: { width: 300, height: 200, ratio: 1.5 }\n};\n\nexport default class extends Component {\n  _isMounted = false;\n\n  constructor(props) {\n    super();\n\n    const {\n      processWithCloudimage, processWithFilerobot, processWithCloudService, uploadWithCloudimageLink, reduceBeforeEdit, cropBeforeEdit,\n      watermark, imageSealing\n    } = props.config;\n\n    this.state = {\n      isShowSpinner: true,\n      isHideCanvas: false,\n      activeTab: null,\n      activeBody: null,\n      currentOperation: null,\n      original: { width: 300, height: 200 },\n      cropDetails: { width: 300, height: 200 },\n      canvasDimensions: { width: 300, height: 200, ratio: 1.5 },\n      processWithFilerobot,\n      processWithCloudimage,\n      processWithCloudService,\n      uploadCloudimageImage: uploadWithCloudimageLink,\n      reduceBeforeEdit,\n      cropBeforeEdit,\n      roundCrop: false,\n      imageSealing: { enabled: false, salt: '', char_count: 10, include_params: null/* include all by default */, ...imageSealing },\n\n      operationsOriginal: [],\n      operationsZoomed: [],\n      operations: [],\n\n      canvasZoomed: null,\n      canvasOriginal: null,\n      isPreResize: false,\n\n      initialZoom: 1,\n\n      ...INITIAL_PARAMS,\n      watermark: watermark || DEFAULT_WATERMARK,\n      focusPoint: {x: null, y: null},\n      shapes: [],\n      selectedShape: {},\n      availableShapes: []\n    }\n  }\n\n  componentDidMount() {\n    this._isMounted = true;\n    this.loadImage();\n    this.determineImageType();\n  }\n\n  componentWillUnmount() {\n    this._isMounted = false;\n  }\n\n  loadImage = () => {\n    let { src } = this.props;\n    const { reduceBeforeEdit: { mode, widthLimit, heightLimit } = {}, watermark } = this.state;\n\n    if (src instanceof Blob) { src = URL.createObjectURL(src); }\n\n    const splittedSrc = src.split('/');\n    const imageName = splittedSrc[splittedSrc.length - 1];\n    const img = new Image();\n    let logoImage = null;\n\n    if (watermark && watermark.url) {\n      logoImage = new Image();\n      logoImage.setAttribute('crossOrigin', 'Anonymous');\n      logoImage.src = watermark.url + (watermark.url.indexOf('?') > -1 ? '&' : '?') + new Date().getTime();\n    }\n\n    img.setAttribute('crossOrigin', 'Anonymous');\n    img.src = src;\n    if (!src.startsWith('data:image/') && !src.startsWith('blob:')) {\n      // Image is not a blob, insert query param to avoid caching\n      img.src = img.src + (img.src.indexOf('?') > -1 ? '&version='  : '?version=') + new Date().getTime();\n    }\n\n    img.onload = () => {\n      const canvasDimensions = { width: img.width, height: img.height, ratio: img.width / img.height };\n      const propsOnApply = {\n        activeBody: 'preResize',\n        isShowSpinner: false,\n        img,\n        logoImage,\n        imageName: imageName.indexOf('?') > -1 ? imageName.slice(0, imageName.indexOf('?')) : imageName,\n      };\n\n      if (mode === 'manual' && (widthLimit < img.width || heightLimit < img.height)) {\n        this.setState({\n          canvasDimensions,\n          ...propsOnApply\n        });\n      } else if (mode === 'auto' && (widthLimit < img.width || heightLimit < img.height)) {\n        if (img.width >= img.height) {\n          const ratio = img.width / img.height;\n          const dimensions = { ratio, width: widthLimit, height: widthLimit / ratio };\n\n          this.setState({\n            preCanvasDimensions: { ...dimensions },\n            canvasDimensions: { ...dimensions },\n            ...propsOnApply,\n            activeBody: 'preview',\n            isPreResize: true\n          });\n        } else {\n          const ratio = img.height / img.width;\n          const dimensions = { ratio, width: heightLimit / ratio, height: heightLimit };\n\n          this.setState({\n            preCanvasDimensions: { ...dimensions },\n            canvasDimensions: { ...dimensions },\n            ...propsOnApply,\n            activeBody: 'preview',\n            isPreResize: true\n          });\n        }\n      } else {\n        const { config } = this.props;\n        const { tools } = config;\n        const isOneTool = tools.length === 1;\n        let activeTab;\n\n        if (isOneTool) {\n          activeTab = tools[0];\n        }\n\n        this.setState({ ...propsOnApply, activeBody: 'preview', isPreResize: false }, () => {\n          this.setState({ activeTab });\n        });\n      }\n    }\n  }\n\n  determineImageType = () => {\n    const { src } = this.props;\n    if (src instanceof Blob) { this.setState({ imageMime: src.type }); return; }\n\n    const xhr = new XMLHttpRequest();\n\n    xhr.open('GET', src);\n    xhr.responseType = 'arraybuffer';\n\n    xhr.onload = ({ target }) => {\n      // TODO: GOOD HACK FOR A TEMP SOLUTION IMAGES & SVG BUT NEED ANOTHER WAY TO MAKE SURE THAT WE COVER MOST OF POSSIBLE IMGS\n      this.setState({ imageMime: imageType(new Uint8Array(target.response))?.mime || 'image/svg+xml' });\n    };\n\n    xhr.send();\n  }\n\n  updateState = (props, callback = () => {}) => {\n    if (this._isMounted) {\n      const editorWrapperId = this.props.config.elementId;\n      const canvas = getCanvasNode(editorWrapperId);\n      props.latestCanvasSize = {\n        width: canvas.width,\n        height: canvas.height\n      }\n\n      this.setState(props, callback);\n    }\n  }\n\n  onRevert = () => {\n    const { cancelLastOperation, activeTab } = this.state;\n\n    this.setState({ activeTab: null, isHideCanvas: true, isShowSpinner: true });\n\n    cancelLastOperation(activeTab, () => {\n      this.setState({ isHideCanvas: false, isShowSpinner: false, ...INITIAL_PARAMS });\n    });\n  }\n\n  onAdjust = (handler, value) => {\n    const { onAdjust } = this.state;\n\n    onAdjust(handler, value);\n  }\n\n  onRotate = (value, correctionDegree, flipX, flipY) => {\n    const { onRotate } = this.state;\n\n    onRotate(value, correctionDegree, flipX, flipY);\n  }\n\n  onFlip = (axis) => {\n    const { flip } = this.state;\n\n    flip(axis);\n  }\n\n  onSave = () => {\n    const { saveImage } = this.state;\n\n    this.setState({ isShowSpinner: true });\n    saveImage();\n  }\n\n  onDownloadImage = () => {\n    const { onBeforeComplete } = this.props;\n    const { downloadImage, getResultCanvas } = this.state;\n    const canvas = getResultCanvas();\n    const isDownload = onBeforeComplete ? onBeforeComplete({ status: 'before-complete', canvas }) : true;\n\n    if (isDownload) {\n      downloadImage(() => {\n        this.props.onComplete({ status: 'success', canvas });\n        this.props.onClose(ON_CLOSE_STATUSES.IMAGE_DOWNLOADED);\n      });\n    } else {\n      this.props.onComplete({ status: 'success', canvas });\n      this.props.onClose(ON_CLOSE_STATUSES.IMAGE_EDITS_COMPLETED);\n    }\n  }\n\n  onApplyEffects = name => {\n    const { applyCorrections, effect } = this.state;\n    const nextEffect = effect === name ? null : name;\n\n    this.setState(\n      { isShowSpinner: true, effect: nextEffect },\n      () => {\n        applyCorrections(\n          () => {\n            this.setState({ isShowSpinner: false })\n          }\n        );\n      }\n    );\n  }\n\n  onApplyFilters = name => {\n    const { applyCorrections, filter } = this.state;\n    const nextFilter = filter === name ? null : name;\n\n    this.setState(\n      { isShowSpinner: true, filter: nextFilter },\n      () => {\n        applyCorrections(\n          () => {\n            this.setState({ isShowSpinner: false })\n          }\n        );\n      }\n    );\n  }\n\n  handleSave = () => {\n    const { processWithFilerobot, processWithCloudService } = this.state;\n\n    if (!processWithFilerobot && !processWithCloudService) {\n      this.onDownloadImage();\n    } else {\n      this.onSave();\n    }\n  }\n\n  apply = (callback) => {\n    const { activeTab, applyChanges } = this.state;\n\n    applyChanges(activeTab, callback);\n    this.setState({ activeTab: null });\n  }\n\n  redoOperation = ({ operationIndex, callback = () => {}, resetActiveTab = true, operationObject = {} }) => {\n    const { applyOperations } = this.state;\n\n    if (resetActiveTab) {\n      this.setState({ activeTab: null, isHideCanvas: true, isShowSpinner: true });\n    } else {\n      this.setState({ isHideCanvas: true, isShowSpinner: true });\n    }\n\n    applyOperations(\n      operationIndex,\n      () => {\n        this.setState({ isHideCanvas: false, isShowSpinner: false }, callback);\n      },\n      operationObject\n    );\n  }\n\n  resetOperations = () => {\n    const { resetAll } = this.state;\n\n    this.setState({ activeTab: null, isHideCanvas: true, isShowSpinner: true });\n\n    resetAll(() => {\n      this.setState({\n        isHideCanvas: false,\n        isShowSpinner: false,\n        ...INITIAL_PARAMS\n      });\n    });\n  }\n\n  onPreResize = (value) => {\n    const { config } = this.props;\n    const { tools } = config;\n    const isOneTool = tools.length === 1;\n    let activeTab;\n\n    if (isOneTool) {\n      activeTab = tools[0];\n    }\n\n    switch (value) {\n      case 'keep':\n        this.setState({ canvasDimensions: {}, isPreResize: false, activeBody: 'preview' }, () => {\n          this.setState({ activeTab });\n        });\n        break;\n      case 'resize':\n        const { canvasDimensions } = this.state;\n        this.setState({ preCanvasDimensions: canvasDimensions, isPreResize: true, activeBody: 'preview' }, () => {\n          this.setState({ activeTab });\n        });\n        break;\n    }\n  }\n\n  render() {\n    const {\n      isShowSpinner, activeTab, operations, operationsOriginal, operationsZoomed, currentOperation, isHideCanvas,\n      cropDetails, original, canvasDimensions, processWithCloudimage, processWithFilerobot, processWithCloudService,\n      uploadCloudimageImage, imageMime, lastOperation, operationList, initialZoom, canvasZoomed, canvasOriginal,\n      reduceBeforeEdit, cropBeforeEdit, img, imageName, activeBody, isPreResize, preCanvasDimensions, logoImage,\n      imageSealing,\n\n      effect,\n      filter,\n      crop,\n      roundCrop,\n      resize,\n      rotate,\n      correctionDegree,\n      flipX,\n      flipY,\n      adjust,\n      watermark,\n      focusPoint,\n      shapes,\n      shapeOperations,\n      selectedShape,\n      availableShapes,\n      latestCanvasSize\n    } = this.state;\n    const { src, config, onClose, onComplete, closeOnLoad = true, t = {}, theme } = this.props;\n    const imageParams = { effect, filter, crop, resize, rotate, flipX, flipY, adjust, correctionDegree };\n    const headerProps = {\n      t,\n      theme,\n      cropDetails,\n      original,\n      activeTab,\n      src,\n      onClose,\n      config,\n      canvasDimensions,\n      processWithCloudimage,\n      processWithFilerobot,\n      processWithCloudService,\n      operations,\n      operationsOriginal,\n      operationsZoomed,\n      initialZoom,\n      isShowSpinner,\n      img,\n      logoImage,\n      imageName,\n      activeBody,\n      preCanvasDimensions,\n      updateState: this.updateState,\n      onRevert: this.onRevert,\n      apply: this.apply,\n      onSave: this.onSave,\n      onFlip: this.onFlip,\n      onApplyEffects: this.onApplyEffects,\n      onApplyFilters: this.onApplyFilters,\n      onRotate: this.onRotate,\n      onAdjust: this.onAdjust,\n      onDownloadImage: this.onDownloadImage,\n      handleSave: this.handleSave,\n\n      ...imageParams,\n      watermark,\n      focusPoint,\n      shapes,\n      shapeOperations,\n      selectedShape,\n      availableShapes\n    };\n    const previewProps = {\n      t,\n      theme,\n      cropDetails,\n      original,\n      activeTab,\n      isShowSpinner,\n      operations,\n      operationsOriginal,\n      operationsZoomed,\n      initialZoom,\n      currentOperation,\n      isHideCanvas,\n      src,\n      imageMime,\n      onClose,\n      onComplete,\n      canvasDimensions,\n      closeOnLoad,\n      config,\n      processWithCloudimage,\n      processWithFilerobot,\n      processWithCloudService,\n      imageSealing,\n      uploadCloudimageImage,\n      lastOperation,\n      operationList,\n      canvasZoomed,\n      canvasOriginal,\n      reduceBeforeEdit,\n      cropBeforeEdit,\n      img,\n      logoImage,\n      imageName,\n      isPreResize,\n      preCanvasDimensions,\n      updateState: this.updateState,\n      handleSave: this.handleSave,\n      onPreResize: this.onPreResize,\n      redoOperation: this.redoOperation,\n      roundCrop,\n\n      ...imageParams,\n      watermark,\n      focusPoint,\n      shapes,\n      shapeOperations,\n      selectedShape,\n      latestCanvasSize\n    };\n    const footerProps = {\n      logoImage,\n      t,\n      theme,\n      activeBody,\n      operations,\n      operationsOriginal,\n      operationsZoomed,\n      initialZoom,\n      currentOperation,\n      processWithCloudimage,\n      processWithCloudService,\n      updateState: this.updateState,\n      redoOperation: this.redoOperation,\n      resetOperations: this.resetOperations,\n      config,\n      watermark\n    };\n\n    return (\n      <Wrapper roundCrop={roundCrop} isLoading={isShowSpinner}>\n\n        <Header {...headerProps}/>\n\n        <PreviewWrapper>\n          {activeBody === 'preview' && <Preview {...previewProps}/>}\n          {activeBody === 'preResize' && <PreResize {...previewProps}/>}\n\n          <Spinner overlay show={isShowSpinner} label={t['spinner.label']}/>\n        </PreviewWrapper>\n        <Footer {...footerProps}/>\n\n      </Wrapper>\n    )\n  }\n}\n","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\config.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Modal.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\is-server-side.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\assets\\theme\\light.js",["502"],"export default {\n  colors: {\n    primaryBg: '#f2f2f2',\n    primaryBgHover: '#fff',\n    secondaryBg: '#fff',\n    secondaryBgHover: '#f9fafb',\n    secondaryBgOpacity: 'rgba(255,255,255, 0.75)',\n    text: '#34444c',\n    textHover: '#1a2329',\n    textMute: '#aaa',\n    textWarn: '#f7931e',\n    accent: '#00707c',\n\n    border: '#aeaeae',\n    borderLight: '#e1e1e1',\n    disabledBg: 'rgba(255, 0, 0, 0.1)',\n  }\n};","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\assets\\theme\\dark.js",["503"],"export default {\n  colors: {\n    primaryBg: '#1e262c',\n    primaryBgHover: '#637381',\n    secondaryBg: '#263138',\n    secondaryBgHover: '#34444c',\n    text: '#F9FAFB',\n    textHover: '#fff',\n    textMute: '#aaa',\n    textWarn: '#f7931e',\n    secondaryBgOpacity: 'rgba(0, 0, 0, 0.75)',\n    accent: '#00707c',\n\n    border: '#161e23',\n    borderLight: '#70777f',\n    disabledBg: 'rgba(255, 0, 0, 0.1)',\n  }\n};","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\index.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\assets\\i18n\\index.js",["504"],"import en from './en';\nimport fr from './fr';\nimport zhCN from './zh-cn';\n\nexport default {\n    en,\n    fr,\n    'zh-cn': zhCN\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\index.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\CloseBtn.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\styleUtils.js",["505","506","507","508","509","510","511","512","513","514","515","516","517","518","519","520","521","522"],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\index.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Toolbar.ui.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\ImageEditor.ui.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Preview.ui.js",["523"],"import React from 'react';\nimport styled from 'styled-components';\n\n\nconst PreviewWrapper = styled.div`\n  height: calc(100% - 187px);\n  text-align: center;\n  line-height: calc(100% - 187px);\n  padding: 20px;\n  position: relative;\n\n  &:before {\n    content: '';\n    display: inline-block;\n    height: 100%;\n    vertical-align: middle;\n  }\n`;\n\nconst PreResizeBox = styled('div')`\n  display: inline-block;\n  vertical-align: middle;\n  width: 100%;\n`;\n\nconst PreviewImgBox = styled.div`\n  display: inline-block;\n  max-height: 100%;\n  max-width: 100%;\n  height: 100%;\n  vertical-align: middle;\n\n  ${props => !props.hideCanvas ? `\n  &:before {\n    content: '';\n    display: inline-block;\n    height: 100%;\n    vertical-align: middle;\n  }` : `\n  canvas {\n    position: relative;\n    left: -9999px;\n  }\n  `};\n\n  /* Limit image width to avoid overflow the container */\n  img {\n    max-width: 100% !important; /* This rule is very important, please do not ignore this! */\n  }\n\n  .filerobot-edit-canvas {\n    display: ${props => props.hide ? 'none' : 'inline-block'};\n    max-height: 100%;\n    max-width: 100%;\n    vertical-align: middle;\n  }\n\n   ${p => p.isShowWatermark && `\ncanvas:after {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: red;\n    opacity: 0.5;\n  }`};\n`;\n\nconst PreviewCanvas = styled('canvas')`\n  width: ${p => p.width || 0}px;\n  height: ${p => p.height || 0}px;\n  display: inline-block;\n  max-height: 100%;\n  max-width: 100%;\n  vertical-align: middle;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  margin: auto;\n  outline: 0;\n`;\n\nconst FocusPointWrap = styled(\n  React.forwardRef(({ width, height, ...rest }, ref) => <div className=\"focus-point\" {...rest} ref={ref} />)\n)(({ width, height }) => ({\n  width,\n  height,\n  position: 'absolute',\n  margin: 'auto',\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n  display: 'inline-block',\n  maxHeight: '100%',\n  maxWidth: '100%',\n  verticalAlign: 'middle',\n}));\n\nconst FocusPointContainer = styled(({ image, ...rest }) => <div {...rest} />)(({ image }) => ({\n  position: 'relative',\n  height: '100%',\n  width: '100%',\n  cursor: 'crosshair',\n  ...(image ? {\n    backgroundImage: `url(${image})`,\n    backgroundSize: 'contain',\n  } : {}),\n}));\n\nconst FocusPoint = styled(\n  ({ x, y, visible, ...rest }) => <span {...rest} />\n)(({ x = 0, y = 0, visible = true }) => ({\n  position: 'absolute',\n  top: y,\n  left: x,\n  visibility: visible ? 'visible' : 'hidden',\n  display: 'inline-block',\n  width: 30,\n  height: 30,\n  transform: 'translate(-50%, -50%)',\n  fontFamily: 'filerobot-image-editor-font !important',\n  color: '#fff',\n  fontSize: 30,\n\n  '::before': {\n    content: \"'\\\\e919'\",\n    position: 'absolute',\n    top: '50%',\n    left: 0,\n    textShadow: '0px 0px 3px #000000'\n  },\n}));\n\nconst FocusPointImg = styled(({visible, ...rest}) => <img {...rest} />)(({visible}) => ({\n  visibility: visible ? 'visible' : 'hidden',\n  maxWidth: '100%',\n  maxHeight: '100%'\n}))\n\n//watermarkURL\n//isShowWatermark\nconst Canvas = styled.canvas.attrs(() => ({}))`\n  display: ${props => props.hide ? 'none' : 'inline-block'};\n  max-height: 100%;\n  max-width: 100%;\n  vertical-align: middle;\n`;\n\nexport {\n  PreviewWrapper, Canvas, PreviewImgBox, PreResizeBox, PreviewCanvas, FocusPoint,\n  FocusPointContainer, FocusPointWrap, FocusPointImg\n}\n","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Footer.ui.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Resize.ui.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Header.ui.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Orientation.ui.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Adjust.ui.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Common.ui.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Button.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\CloseBtn.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Watermark.ui.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Crop.ui.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Spinner.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\assets\\i18n\\en.js",["524"],"export default {\n  'header.image_editor_title': 'Filerobot Image Editor',\n  'header.toggle_fullscreen': 'Toggle fullscreen',\n  'header.close': 'Close',\n  'header.close_modal': 'Close window',\n  'toolbar.download': 'Download',\n  'toolbar.save': 'Save',\n  'toolbar.apply': 'Apply',\n  'toolbar.cancel': 'Cancel',\n  'toolbar.go_back': 'Go Back',\n  'toolbar.adjust': 'Adjust',\n  'toolbar.effects': 'Effects',\n  'toolbar.filters': 'Filters',\n  'toolbar.orientation': 'Orientation',\n  'toolbar.crop': 'Crop',\n  'toolbar.resize': 'Resize',\n  'toolbar.watermark': 'Watermark',\n  'toolbar.focus_point': 'Focus point',\n  'toolbar.shapes': 'Shapes',\n  'toolbar.image': 'Image',\n  'toolbar.text': 'Text',\n  'adjust.brightness': 'Brightness',\n  'adjust.contrast': 'Contrast',\n  'adjust.exposure': 'Exposure',\n  'adjust.saturation': 'Saturation',\n  'orientation.rotate_l': 'Rotate Left',\n  'orientation.rotate_r': 'Rotate Right',\n  'orientation.flip_h': 'Flip Horizontally',\n  'orientation.flip_v': 'Flip Vertically',\n  'pre_resize.title': 'Would you like to reduce resolution before editing the image?',\n  'pre_resize.keep_original_resolution': 'Keep original resolution',\n  'pre_resize.resize_n_continue': 'Resize & Continue',\n  'footer.reset': 'Reset',\n  'footer.undo': 'Undo',\n  'footer.redo': 'Redo',\n  'spinner.label': 'Processing...',\n  'warning.too_big_resolution': 'The resolution of the image is too big for the web. It can cause problems with Image Editor performance.',\n  'common.x': 'x',\n  'common.y': 'y',\n  'common.width': 'width',\n  'common.height': 'height',\n  'common.custom': 'custom',\n  'common.original': 'original',\n  'common.square': 'square',\n  'common.opacity': 'Opacity',\n  'common.apply_watermark': 'Apply watermark',\n  'common.url': 'URL',\n  'common.upload': 'Upload',\n  'common.gallery': 'Gallery',\n  'common.text': 'Text',\n};","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\assets\\i18n\\zh-cn.js",["525"],"export default {\n  'header.image_editor_title': 'Filerobot 图片编辑器',\n  'header.toggle_fullscreen': 'Toggle fullscreen', // TODO: Translate\n  'header.close_modal': 'Close window', // TODO: Translate\n  'toolbar.download': '下载',\n  'toolbar.save': '保存',\n  'toolbar.apply': '应用',\n  'toolbar.close': 'Close', // TODO: Translate\n  'toolbar.cancel': '取消',\n  'toolbar.go_back': '后退',\n  'toolbar.adjust': '调整',\n  'toolbar.effects': '效果',\n  'toolbar.filters': '滤镜',\n  'toolbar.orientation': '方向',\n  'toolbar.crop': '裁切',\n  'toolbar.resize': '缩放',\n  'toolbar.watermark': '水印',\n  'toolbar.focus_point': 'Focus point', // TODO translate\n  'toolbar.shapes': 'Shapes',// TODO translate\n  'toolbar.image': 'Image',// TODO translate\n  'toolbar.text': 'Text',// TODO translate\n  'adjust.brightness': '亮度',\n  'adjust.contrast': '对比对',\n  'adjust.exposure': '曝光度',\n  'adjust.saturation': '饱和度',\n  'orientation.rotate_l': '向左旋转',\n  'orientation.rotate_r': '向右旋转',\n  'orientation.flip_h': '水平翻转',\n  'orientation.flip_v': '垂直翻转',\n  'pre_resize.title': '是否需要在开始编辑之前缩小图片的分辨率?',\n  'pre_resize.keep_original_resolution': '保持原始分辨率',\n  'pre_resize.resize_n_continue': '缩小并继续',\n  'footer.reset': '重置',\n  'footer.undo': '撤销',\n  'footer.redo': '重做',\n  'spinner.label': '处理中...',\n  'warning.too_big_resolution': '图片的分辨率过大，这会严重影响图片编辑器的性能。',\n  'common.x': 'x', // TODO translate\n  'common.y': 'y', // TODO translate\n  'common.width': '宽度',\n  'common.height': '高度',\n  'common.custom': '自定义',\n  'common.original': '原始比例',\n  'common.square': '方形',\n  'common.banner': '通栏',\n  'common.opacity': '透明度',\n  'common.apply_watermark': '应用水印',\n  'common.url': 'URL',\n  'common.upload': 'Upload',\n  'common.gallery': 'Gallery',\n};\n","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\assets\\i18n\\fr.js",["526"],"export default {\n  'header.image_editor_title': 'Éditeur d\\'Image Filerobot',\n  'header.toggle_fullscreen': 'Basculer en plein écran',\n  'header.close_modal': 'Fermer la fenêtre',\n  'toolbar.download': 'Télécharger',\n  'toolbar.save': 'Sauvegarder',\n  'toolbar.apply': 'Appliquer',\n  'toolbar.close': 'Fermer',\n  'toolbar.cancel': 'Annuler',\n  'toolbar.go_back': 'Retour',\n  'toolbar.adjust': 'Ajuster',\n  'toolbar.effects': 'Effets',\n  'toolbar.filters': 'Filtres',\n  'toolbar.orientation': 'Orientation',\n  'toolbar.crop': 'Rogner',\n  'toolbar.resize': 'Redimensionner',\n  'toolbar.watermark': 'Watermark',\n  'toolbar.focus_point': 'Focus point', // TODO translate\n  'toolbar.shapes': 'Shapes',// TODO translate\n  'toolbar.image': 'Image',// TODO translate\n  'toolbar.text': 'Text',// TODO translate\n  'adjust.brightness': 'Luminosité',\n  'adjust.contrast': 'Contraste',\n  'adjust.exposure': 'Exposition',\n  'adjust.saturation': 'Saturation',\n  'orientation.rotate_l': 'Rotation Gauche',\n  'orientation.rotate_r': 'Rotation Droite',\n  'orientation.flip_h': 'Miroir Horizontal',\n  'orientation.flip_v': 'Miroir Vertical',\n  'pre_resize.title': 'Voulez-vous réduire la résolution de l\\'image avant d\\'éditer l\\'image ?',\n  'pre_resize.keep_original_resolution': 'Conserver la résolution d\\'origine',\n  'pre_resize.resize_n_continue': 'Redimensionner et Continuer',\n  'footer.reset': 'Réinitialiser',\n  'footer.undo': 'Annuler',\n  'footer.redo': 'Refaire',\n  'spinner.label': 'Transformation...',\n  'warning.too_big_resolution': 'La résolution de l\\'image est trop grande pour le web et peut endommager les performances de l\\'Éditeur d\\'Image Filerobot.',\n  'common.x': 'x', // TODO translate\n  'common.y': 'y', // TODO translate\n  'common.width': 'largeur',\n  'common.height': 'hauteur',\n  'common.custom': 'custom',\n  'common.original': 'original',\n  'common.square': 'carré',\n  'common.opacity': 'opacité',\n  'common.apply_watermark': 'Appliquer watermark',\n  'common.url': 'URL',\n  'common.upload': 'Upload',\n  'common.gallery': 'Gallery',\n};","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\index.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Footer\\Footer.js",["527"],"import React, { Component } from 'react';\nimport { Footer, PreviousBtn, NextBtn, ResetBtn, Switcher, FullscreenBtn } from '../../styledComponents';\nimport { toggleModalFullscreen } from '../../utils/full-screen-handle';\n\n\nexport default class extends Component {\n  onApplyWatermarkChange = () => {\n    this.props.updateState({\n      watermark: { ...this.props.watermark, applyByDefault: !this.props.watermark.applyByDefault }\n    });\n  }\n\n  render() {\n    const {\n      initialZoom, operations, operationsZoomed, currentOperation = null, redoOperation,\n      resetOperations, activeBody, t, logoImage, watermark, config\n    } = this.props;\n    const { elementId } = config;\n    const operationList = initialZoom === 1 ? operations : operationsZoomed;\n    const currentOperationIndex = operationList.findIndex(operation => operation === currentOperation);\n    const isCurrentOperationLast = currentOperation && (operationList[operationList.length - 1] === currentOperation);\n    const isPrevForbidden = (operationList.length < 1) || (currentOperationIndex === -1);\n    const isNextForbidden = (operationList.length < 2 || (operationList.length > 1 && isCurrentOperationLast)) &&\n      (currentOperationIndex !== -1 || operationList.length !== 1);\n\n    return (\n      <Footer>\n        <ResetBtn\n          muted={activeBody !== 'preview'}\n          onClick={() => { activeBody === 'preview' && resetOperations(); }}\n          title={t['footer.reset']}\n        />\n\n        <PreviousBtn\n          onClick={() => { !isPrevForbidden && redoOperation({\n            operationIndex: currentOperationIndex - 1,\n            operationObject: { ...operationList[currentOperationIndex], index: currentOperationIndex }});\n          }}\n          muted={isPrevForbidden}\n          title={t['footer.undo']}\n        />\n        <NextBtn\n          onClick={() => { !isNextForbidden && redoOperation({\n            operationIndex: currentOperationIndex + 1,\n            operationObject: { ...operationList[currentOperationIndex], index: currentOperationIndex } });\n          }}\n          muted={isNextForbidden}\n          title={t['footer.redo']}\n        />\n        <FullscreenBtn onClick={() => toggleModalFullscreen(elementId)} title={t[`header.toggle_fullscreen`]} />\n\n        {logoImage && watermark &&\n        <Switcher\n          id=\"switch-watermark-footer\"\n          checked={watermark && watermark.applyByDefault}\n          handleChange={this.onApplyWatermarkChange}\n          text={t['common.apply_watermark']}\n        />}\n      </Footer>\n    )\n  }\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Preview\\Preview.js",["528","529","530"],"import React, { Component } from 'react';\nimport { PreviewImgBox } from '../../styledComponents';\nimport ImageManipulator from './ImageManipulator';\nimport FocusPointPreview from './FocusPointPreview';\nimport CustomizedCanvas from '../CustomizedCanvas';\nimport { getCanvasNode } from '../../utils';\n\nexport default class extends Component {\n  render() {\n    const {\n      activeTab, isHideCanvas, watermark = {}, focusPoint, original, updateState, src, shapes,\n      selectedShape, config: { colorScheme, elementId: editorWrapperId, processWithCloudimage, theme }, roundCrop,\n      latestCanvasSize\n    } = this.props;\n\n    const { applyByDefault } = watermark;\n    const canvas = getCanvasNode(editorWrapperId);\n    const canvasRect = canvas && canvas.getBoundingClientRect() || {};\n\n    return (\n      <PreviewImgBox\n        id=\"preview-img-box\"\n        hideCanvas={activeTab === 'crop' || isHideCanvas}\n        isShowWatermark={applyByDefault}\n      >\n        <ImageManipulator {...this.props}/>\n        {activeTab !== 'focus_point' &&\n        <CustomizedCanvas\n          width={canvasRect.width}\n          height={canvasRect.height}\n          shapes={shapes}\n          updateState={updateState}\n          selectedShape={selectedShape}\n          activeTab={activeTab}\n          round={roundCrop}\n          latestCanvasSize={latestCanvasSize}\n          colorScheme={colorScheme}\n          theme={theme}\n          wrapperId={editorWrapperId}\n          processWithCloudimage={processWithCloudimage}\n        />}\n\n        {activeTab === 'focus_point' && (\n          <FocusPointPreview\n            src={src}\n            updateState={updateState}\n            focusPoint={focusPoint}\n            original={original}\n          />\n        )}\n      </PreviewImgBox>\n    )\n  }\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Toolbar.js",["531"],"import React, { Component } from 'react';\nimport { Toolbar, NoClickOverlay, NoClickToolbar } from '../../styledComponents';\nimport Tool from './Tool';\nimport Effects from './Effects';\nimport Filters from './Filters';\nimport Crop from './Crop';\nimport Resize from './Resize';\nimport Orientation from './Orientation';\nimport Adjust from './Adjust';\nimport Watermark from './Watermark';\nimport FocusPoint from './FocusPoint';\nimport Shapes from './Shapes';\nimport Image from './Image';\nimport Text from './Text';\n\n\nexport default class extends Component {\n  render() {\n    const { activeTab, isShowSpinner, activeBody, config } = this.props;\n    const { tools } = config;\n\n    return (\n      <Toolbar overlayYHidden={activeTab !== 'watermark'}>\n        {!activeTab && tools.map(name => <Tool name={name} key={name} {...this.props}/>)}\n        {activeTab === 'adjust' && <Adjust {...this.props}/>}\n        {activeTab === 'effects' && <Effects {...this.props}/>}\n        {activeTab === 'filters' && <Filters {...this.props}/>}\n        {activeTab === 'rotate' && <Orientation {...this.props}/>}\n        {activeTab === 'crop' && <Crop {...this.props}/>}\n        {activeTab === 'resize' && <Resize {...this.props}/>}\n        {activeTab === 'watermark' && <Watermark {...this.props}/>}\n        {activeTab === 'focus_point' && <FocusPoint {...this.props}/>}\n        {activeTab === 'shapes' && <Shapes {...this.props}/>}\n        {activeTab === 'image' && <Image {...this.props}/>}\n        {activeTab === 'text' && <Text {...this.props}/>}\n        {(isShowSpinner) && <NoClickOverlay/>}\n        {activeBody !== 'preview' && <NoClickToolbar/>}\n      </Toolbar>\n    )\n  }\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\PreResize\\PreResize.js",["532"],"import React, { Component } from 'react';\nimport {\n  BlockRatioBtn,\n  BlockRatioIcon,\n  BlockRatioWrapper,\n  Button,\n  FieldInput,\n  FieldLabel,\n  FieldSet,\n  PreResizeBox,\n  ResizeBox,\n  ResizeWrapper,\n  PreResizeActions,\n  PreResizeWarning,\n  PreResizeInner\n} from '../../styledComponents';\n\n\nexport default class extends Component {\n  state = {\n    isBlockRatio: false\n  };\n\n  componentDidMount() {\n    const { operations, processWithCloudService, updateState, forceApplyOperations } = this.props;\n    const operationIndex = operations.findIndex(({ stack }) => stack[0].name === 'resize');\n\n    if (operationIndex > -1 && processWithCloudService) {\n      operations.splice(operationIndex, 1);\n      updateState({ operations });\n      forceApplyOperations(operations, 'resize');\n    }\n  }\n\n  changeWidth = (event) => {\n    const { isBlockRatio } = this.state;\n    const { canvasDimensions } = this.props;\n    const width = event.target.value;\n    let height = canvasDimensions.height;\n\n    if (!isBlockRatio)\n      height = (width && (width / canvasDimensions.ratio)) || 1;\n\n    this.props.updateState({ canvasDimensions: { ...canvasDimensions, width, height } });\n  }\n\n  changeHeight = (event) => {\n    const { isBlockRatio } = this.state;\n    const { canvasDimensions } = this.props;\n    const height = event.target.value;\n    let width = canvasDimensions.width;\n\n    if (!isBlockRatio)\n      width = (height && (height * canvasDimensions.ratio)) || 1;\n\n    this.props.updateState({ canvasDimensions: { ...canvasDimensions, width, height } });\n  }\n\n  toggleRatio = () => {\n    this.setState({ isBlockRatio: !this.state.isBlockRatio });\n  }\n\n  render() {\n    const { isBlockRatio } = this.state;\n    const { canvasDimensions, processWithCloudService, onPreResize, t } = this.props;\n\n    return (\n      <PreResizeBox id=\"preview-img-box\">\n\n        <PreResizeWarning>{t['warning.too_big_resolution']}</PreResizeWarning>\n\n        <PreResizeInner>\n          <h4>{t['pre_resize.title']}</h4>\n\n          <ResizeWrapper>\n            <ResizeBox>\n              <FieldSet>\n                <FieldLabel>{t['common.width']}</FieldLabel>\n                <FieldInput\n                  fullSize\n                  value={parseInt(canvasDimensions.width, 10) || ''}\n                  onChange={this.changeWidth}\n                />\n              </FieldSet>\n              <BlockRatioWrapper>\n                <BlockRatioBtn\n                  active={!isBlockRatio}\n                  style={processWithCloudService ? { cursor: 'not-allowed' } : {}}\n                  link\n                  onClick={() => { !processWithCloudService && this.toggleRatio(); }}\n                >\n                  <BlockRatioIcon active={!isBlockRatio} style={processWithCloudService ? { cursor: 'not-allowed' } : {}}/>\n                </BlockRatioBtn>\n              </BlockRatioWrapper>\n              <FieldSet>\n                <FieldLabel>{t['common.height']}</FieldLabel>\n                <FieldInput\n                  fullSize\n                  value={parseInt(canvasDimensions.height, 10) || ''}\n                  onChange={this.changeHeight}\n                />\n              </FieldSet>\n            </ResizeBox>\n          </ResizeWrapper>\n\n          <PreResizeActions>\n            <p>\n              <Button\n                themeColor\n                themeBtn={true}\n                onClick={() => { onPreResize('keep'); }}\n              >{t['pre_resize.keep_original_resolution']}</Button>\n            </p>\n            <p>\n              <Button\n                themeColor\n                success={true}\n                onClick={() => { onPreResize('resize'); }}\n              >{t['pre_resize.resize_n_continue']}</Button>\n            </p>\n          </PreResizeActions>\n        </PreResizeInner>\n\n      </PreResizeBox>\n    )\n  }\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Tool.js",["533"],"import React, { Component } from 'react';\nimport { ToolWrapper, ToolIcon, ToolLabel } from '../../styledComponents/index';\n\n\nexport default class extends Component {\n  render() {\n    const { name, activeTab, updateState, t } = this.props;\n    const filteredName = name === 'rotate' ? 'orientation' : name;\n\n    return (\n      <ToolWrapper\n        active={activeTab === name}\n        onClick={() => updateState({ activeTab: name })}\n      >\n        <ToolIcon name={name}/>\n        <ToolLabel>{t[`toolbar.${filteredName}`]}</ToolLabel>\n      </ToolWrapper>\n    )\n  }\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Header\\Header.js",["534"],"import React, { Component } from 'react';\nimport {\n  HeaderWrapper, HeaderTop, Title, ButtonsWrapper, ToolbarWrapper, CancelBtn, Button, CloseBtn\n} from '../../styledComponents';\nimport { Toolbar } from '../';\nimport { ON_CLOSE_STATUSES } from '../../config';\n\n\nexport default class extends Component {\n  render() {\n    const {\n      activeTab, onRevert, apply, onClose, processWithCloudService, processWithFilerobot,\n      handleSave, t, config\n    } = this.props;\n    const { tools, closeButtonProps, noCapitalStrs } = config;\n    const isOneTool = tools.length === 1;\n    const filteredName = activeTab === 'rotate' ? 'orientation' : activeTab;\n    const onFinishButtonLabel = (!processWithCloudService && !processWithFilerobot) ? t['toolbar.download'] : t['toolbar.save'];\n    const applyAndSave = () => { apply(handleSave); };\n    const cancelBtnClosingFn = () => onClose(ON_CLOSE_STATUSES.TOOLBAR_CANCEL_BTN_CLICKED);\n\n    return (\n      <HeaderWrapper>\n        <HeaderTop>\n          <Title noCapitalStrs={noCapitalStrs}>{t[`toolbar.${filteredName}`] || t[`header.image_editor_title`]}</Title>\n          <ButtonsWrapper>\n            <CancelBtn\n              hide={!activeTab}\n              onClick={isOneTool ? cancelBtnClosingFn : onRevert}\n              noCapitalStrs={noCapitalStrs}\n              sm default fullSize\n            >\n              {t[`toolbar.cancel`]}\n            </CancelBtn>\n            <Button\n              themeColor\n              sm\n              success={!activeTab || activeTab === 'resize'}\n              themeBtn={activeTab}\n              onClick={isOneTool ? applyAndSave : !activeTab ? () => { handleSave(); } : () => { apply(); }}\n            >\n              {!activeTab || activeTab === 'resize' ? onFinishButtonLabel : t['toolbar.apply']}\n            </Button>\n          </ButtonsWrapper>\n          \n          <CloseBtn onClick={onClose} title={t[`header.close_modal`]} {...closeButtonProps}>\n            {!closeButtonProps?.noLabel && (closeButtonProps?.label || t['header.close'])}\n          </CloseBtn>\n        </HeaderTop>\n\n        <ToolbarWrapper overlayYHidden={activeTab !== 'watermark'}>\n          <Toolbar {...this.props}/>\n        </ToolbarWrapper>\n      </HeaderWrapper>\n    )\n  }\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\b64-to-blob.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\deep-copy.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\adjust-api.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-base-api.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-base-url.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-canvas-node.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-effect-handler-name.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-icon.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-label.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-watermark-position.js",["535"],"export const getWatermarkSquaredPosition = (position = 'center', canvas, width, height) => {\n  const canvasRect = canvas.getBoundingClientRect();\n\n  const scaleRatio = 30 / 100; // 30%\n\n  const scaledHeight = canvasRect.height * scaleRatio;\n  const scaledWidth = canvasRect.width * scaleRatio;\n\n  if (scaledWidth < width || scaledHeight < height) {\n    const aspectRatio = width / height;\n    if (height > width) {\n      height = scaledHeight;\n      width = height * aspectRatio;\n    } else {\n      width = scaledWidth;\n      height = width / aspectRatio;\n    }\n  }\n\n  const centerPositionX = (canvasRect.width / 2) - (width / 2);\n  const centerPositionY = (canvasRect.height / 2) - (height / 2);\n\n  if (position === 'center') {\n    return [centerPositionX, centerPositionY, width, height];\n  }\n\n  position = position.split('-');\n\n  const paddingSpace = 1.5 / 100; // 1.5%\n  \n  const widthSpace = canvasRect.width * paddingSpace;\n  const heightSpace = canvasRect.height * paddingSpace;\n\n  const rightPosition = (canvasRect.width - width) - widthSpace;\n  const bottomPosition = (canvasRect.height - height) - heightSpace;\n  \n  return [\n    ...position.map(\n        (p, i) => {\n        if (p === 'center') { return i === 0 ? centerPositionX : centerPositionY }\n        if (p === 'right') { return rightPosition; }\n        if (p === 'bottom') { return bottomPosition; }\n        if (p === 'left') { return widthSpace; }\n        if (p === 'top') { return heightSpace; }\n      }\n    ),\n    width,\n    height\n  ]\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-inner-box-size.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-image-sealing-params.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\round-decimal-point.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\get-secret-header-name.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\convert.js",["536","537","538"],"/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS205: Consider reworking code to avoid use of IIFEs\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n// Tons of color conversion utility functions.\nclass Convert {\n  // Converts the hex representation of a color to RGB values.\n  // Hex value can optionally start with the hash (#).\n  //\n  // @param  [String] hex  The colors hex value\n  // @return [Array]       The RGB representation\n  static hexToRGB(hex) {\n    if (hex.charAt(0) === \"#\") { hex = hex.substr(1); }\n    const r = parseInt(hex.substr(0, 2), 16);\n    const g = parseInt(hex.substr(2, 2), 16);\n    const b = parseInt(hex.substr(4, 2), 16);\n\n    return {r, g, b};\n  }\n\n  // Converts an RGB color to HSL.\n  // Assumes r, g, and b are in the set [0, 255] and\n  // returns h, s, and l in the set [0, 1].\n  //\n  // @overload rgbToHSL(r, g, b)\n  //   @param   [Number]  r   Red channel\n  //   @param   [Number]  g   Green channel\n  //   @param   [Number]  b   Blue channel\n  //\n  // @overload rgbToHSL(rgb)\n  //   @param [Object] rgb The RGB object.\n  //   @option rgb [Number] r The red channel.\n  //   @option rgb [Number] g The green channel.\n  //   @option rgb [Number] b The blue channel.\n  //\n  // @return  [Array]       The HSL representation\n  static rgbToHSL(r, g, b) {\n    let h, s;\n    if (typeof r === \"object\") {\n      ({ g } = r);\n      ({ b } = r);\n      ({ r } = r);\n    }\n\n    r /= 255;\n    g /= 255;\n    b /= 255;\n\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const l = (max + min) / 2;\n\n    if (max === min) {\n      h = (s = 0);\n    } else {\n      const d = max - min;\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      h = (() => { switch (max) {\n        case r: return ((g - b) / d) + (g < b ? 6 : 0);\n        case g: return ((b - r) / d) + 2;\n        case b: return ((r - g) / d) + 4;\n      } })();\n\n      h /= 6;\n    }\n\n    return {h, s, l};\n  }\n\n  // Converts an HSL color value to RGB. Conversion formula\n  // adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n  // Assumes h, s, and l are contained in the set [0, 1] and\n  // returns r, g, and b in the set [0, 255].\n  //\n  // @overload hslToRGB(h, s, l)\n  //   @param   [Number]  h       The hue\n  //   @param   [Number]  s       The saturation\n  //   @param   [Number]  l       The lightness\n  //\n  // @overload hslToRGB(hsl)\n  //   @param [Object] hsl The HSL object.\n  //   @option hsl [Number] h The hue.\n  //   @option hsl [Number] s The saturation.\n  //   @option hsl [Number] l The lightness.\n  //\n  // @return  [Array]           The RGB representation\n  static hslToRGB(h, s, l) {\n    let b, g, r;\n    if (typeof h === \"object\") {\n      ({ s } = h);\n      ({ l } = h);\n      ({ h } = h);\n    }\n\n    if (s === 0) {\n      r = (g = (b = l));\n    } else {\n      const q = l < 0.5 ? l * (1 + s) : (l + s) - (l * s);\n      const p = (2 * l) - q;\n\n      r = this.hueToRGB(p, q, h + (1/3));\n      g = this.hueToRGB(p, q, h);\n      b = this.hueToRGB(p, q, h - (1/3));\n    }\n\n    return {r: r * 255, g: g * 255, b: b * 255};\n  }\n\n  // Converts from the hue color space back to RGB.\n  //\n  // @param [Number] p\n  // @param [Number] q\n  // @param [Number] t\n  // @return [Number] RGB value\n  static hueToRGB(p, q, t) {\n    if (t < 0) { t += 1; }\n    if (t > 1) { t -= 1; }\n    if (t < (1/6)) { return p + ((q - p) * 6 * t); }\n    if (t < (1/2)) { return q; }\n    if (t < (2/3)) { return p + ((q - p) * ((2/3) - t) * 6); }\n    return p;\n  }\n\n  // Converts an RGB color value to HSV. Conversion formula\n  // adapted from {http://en.wikipedia.org/wiki/HSV_color_space}.\n  // Assumes r, g, and b are contained in the set [0, 255] and\n  // returns h, s, and v in the set [0, 1].\n  //\n  // @param   [Number]  r       The red color value\n  // @param   [Number]  g       The green color value\n  // @param   [Number]  b       The blue color value\n  // @return  [Array]           The HSV representation\n  static rgbToHSV(r, g, b) {\n    let h;\n    r /= 255;\n    g /= 255;\n    b /= 255;\n\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const v = max;\n    const d = max - min;\n\n    const s = max === 0 ? 0 : d / max;\n\n    if (max === min) {\n      h = 0;\n    } else {\n      h = (() => { switch (max) {\n        case r: return ((g - b) / d) + (g < b ? 6 : 0);\n        case g: return ((b - r) / d) + 2;\n        case b: return ((r - g) / d) + 4;\n      } })();\n\n      h /= 6;\n    }\n\n    return {h, s, v};\n  }\n\n  // Converts an HSV color value to RGB. Conversion formula\n  // adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n  // Assumes h, s, and v are contained in the set [0, 1] and\n  // returns r, g, and b in the set [0, 255].\n  //\n  // @param   [Number]  h       The hue\n  // @param   [Number]  s       The saturation\n  // @param   [Number]  v       The value\n  // @return  [Array]           The RGB representation\n  static hsvToRGB(h, s, v) {\n    let b, g, r;\n    const i = Math.floor(h * 6);\n    const f = (h * 6) - i;\n    const p = v * (1 - s);\n    const q = v * (1 - (f * s));\n    const t = v * (1 - ((1 - f) * s));\n\n    switch (i % 6) {\n      case 0: r = v; g = t; b = p; break;\n      case 1: r = q; g = v; b = p; break;\n      case 2: r = p; g = v; b = t; break;\n      case 3: r = p; g = q; b = v; break;\n      case 4: r = t; g = p; b = v; break;\n      case 5: r = v; g = p; b = q; break;\n    }\n\n    return {\n      r: Math.floor(r * 255),\n      g: Math.floor(g * 255),\n      b: Math.floor(b * 255)\n    };\n  }\n\n  // Converts a RGB color value to the XYZ color space. Formulas\n  // are based on http://en.wikipedia.org/wiki/SRGB assuming that\n  // RGB values are sRGB.\n  //\n  // Assumes r, g, and b are contained in the set [0, 255] and\n  // returns x, y, and z.\n  //\n  // @param   [Number]  r       The red color value\n  // @param   [Number]  g       The green color value\n  // @param   [Number]  b       The blue color value\n  // @return  [Array]           The XYZ representation\n  static rgbToXYZ(r, g, b) {\n    r /= 255;\n    g /= 255;\n    b /= 255;\n\n    if (r > 0.04045) {\n      r = Math.pow((r + 0.055) / 1.055, 2.4);\n    } else {\n      r /= 12.92;\n    }\n\n    if (g > 0.04045) {\n      g = Math.pow((g + 0.055) / 1.055, 2.4);\n    } else {\n      g /= 12.92;\n    }\n\n    if (b > 0.04045) {\n      b = Math.pow((b + 0.055) / 1.055, 2.4);\n    } else {\n      b /= 12.92;\n    }\n\n    const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n    const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n    const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n    return {x: x * 100, y: y * 100, z: z * 100};\n  }\n\n  // Converts a XYZ color value to the sRGB color space. Formulas\n  // are based on http://en.wikipedia.org/wiki/SRGB and the resulting\n  // RGB value will be in the sRGB color space.\n  // Assumes x, y and z values are whatever they are and returns\n  // r, g and b in the set [0, 255].\n  //\n  // @param   [Number]  x       The X value\n  // @param   [Number]  y       The Y value\n  // @param   [Number]  z       The Z value\n  // @return  [Array]           The RGB representation\n  static xyzToRGB(x, y, z) {\n    x /= 100;\n    y /= 100;\n    z /= 100;\n\n    let r = (3.2406  * x) + (-1.5372 * y) + (-0.4986 * z);\n    let g = (-0.9689 * x) + (1.8758  * y) + (0.0415  * z);\n    let b = (0.0557  * x) + (-0.2040 * y) + (1.0570  * z);\n\n    if (r > 0.0031308) {\n      r = (1.055 * Math.pow(r, 0.4166666667)) - 0.055;\n    } else {\n      r *= 12.92;\n    }\n\n    if (g > 0.0031308) {\n      g = (1.055 * Math.pow(g, 0.4166666667)) - 0.055;\n    } else {\n      g *= 12.92;\n    }\n\n    if (b > 0.0031308) {\n      b = (1.055 * Math.pow(b, 0.4166666667)) - 0.055;\n    } else {\n      b *= 12.92;\n    }\n\n    return {r: r * 255, g: g * 255, b: b * 255};\n  }\n\n  // Converts a XYZ color value to the CIELAB color space. Formulas\n  // are based on http://en.wikipedia.org/wiki/Lab_color_space\n  // The reference white point used in the conversion is D65.\n  // Assumes x, y and z values are whatever they are and returns\n  // L*, a* and b* values\n  //\n  // @overload xyzToLab(x, y, z)\n  //   @param   [Number]  x       The X value\n  //   @param   [Number]  y       The Y value\n  //   @param   [Number]  z       The Z value\n  //\n  // @overload xyzToLab(xyz)\n  //   @param [Object] xyz The XYZ object.\n  //   @option xyz [Number] x The X value.\n  //   @option xyz [Number] y The Y value.\n  //   @option xyz [Number] z The z value.\n  //\n  // @return [Array] The Lab representation\n  static xyzToLab(x, y, z) {\n    if (typeof x === \"object\") {\n      ({ y } = x);\n      ({ z } = x);\n      ({ x } = x);\n    }\n\n    const whiteX = 95.047;\n    const whiteY = 100.0;\n    const whiteZ = 108.883;\n\n    x /= whiteX;\n    y /= whiteY;\n    z /= whiteZ;\n\n    if (x > 0.008856451679) {\n      x = Math.pow(x, 0.3333333333);\n    } else {\n      x = (7.787037037 * x) + 0.1379310345;\n    }\n\n    if (y > 0.008856451679) {\n      y = Math.pow(y, 0.3333333333);\n    } else {\n      y = (7.787037037 * y) + 0.1379310345;\n    }\n\n    if (z > 0.008856451679) {\n      z = Math.pow(z, 0.3333333333);\n    } else {\n      z = (7.787037037 * z) + 0.1379310345;\n    }\n\n    const l = (116 * y) - 16;\n    const a = 500 * (x - y);\n    const b = 200 * (y - z);\n\n    return {l, a, b};\n  }\n\n  // Converts a L*, a*, b* color values from the CIELAB color space\n  // to the XYZ color space. Formulas are based on\n  // http://en.wikipedia.org/wiki/Lab_color_space\n  //\n  // The reference white point used in the conversion is D65.\n  // Assumes L*, a* and b* values are whatever they are and returns\n  // x, y and z values.\n  //\n  // @overload labToXYZ(l, a, b)\n  //   @param   [Number]  l       The L* value\n  //   @param   [Number]  a       The a* value\n  //   @param   [Number]  b       The b* value\n  //\n  // @overload labToXYZ(lab)\n  //   @param [Object] lab The LAB values\n  //   @option lab [Number] l The L* value.\n  //   @option lab [Number] a The a* value.\n  //   @option lab [Number] b The b* value.\n  //\n  // @return  [Array]           The XYZ representation\n  static labToXYZ(l, a, b) {\n    if (typeof l === \"object\") {\n      ({ a } = l);\n      ({ b } = l);\n      ({ l } = l);\n    }\n\n    let y = (l + 16) / 116;\n    let x = y + (a / 500);\n    let z = y - (b / 200);\n\n    if (x > 0.2068965517) {\n      x = x * x * x;\n    } else {\n      x = 0.1284185493 * (x - 0.1379310345);\n    }\n\n    if (y > 0.2068965517) {\n      y = y * y * y;\n    } else {\n      y = 0.1284185493 * (y - 0.1379310345);\n    }\n\n    if (z > 0.2068965517) {\n      z = z * z * z;\n    } else {\n      z = 0.1284185493 * (z - 0.1379310345);\n    }\n\n    // D65 reference white point\n    return {x: x * 95.047, y: y * 100.0, z: z * 108.883};\n  }\n\n  // Converts L*, a*, b* back to RGB values.\n  //\n  // @see Convert.rgbToXYZ\n  // @see Convert.xyzToLab\n  static rgbToLab(r, g, b) {\n    if (typeof r === \"object\") {\n      ({ g } = r);\n      ({ b } = r);\n      ({ r } = r);\n    }\n\n    const xyz = this.rgbToXYZ(r, g, b);\n    return this.xyzToLab(xyz);\n  }\n\n  static labToRGB(l, a, b) {}\n}\n\nCaman.Convert = Convert;","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\calculate.js",["539","540","541","542"],"/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS202: Simplify dynamic range loops\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n// Various math-heavy helpers that are used throughout CamanJS.\nclass Calculate {\n  // Calculates the distance between two points.\n\n  // @param [Number] x1 1st point x-coordinate.\n  // @param [Number] y1 1st point y-coordinate.\n  // @param [Number] x2 2nd point x-coordinate.\n  // @param [Number] y2 2nd point y-coordinate.\n  // @return [Number] The distance between the two points.\n  static distance(x1, y1, x2, y2) {\n    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n  }\n\n  // Generates a pseudorandom number that lies within the max - mix range. The number can be either\n  // an integer or a float depending on what the user specifies.\n\n  // @param [Number] min The lower bound (inclusive).\n  // @param [Number] max The upper bound (inclusive).\n  // @param [Boolean] getFloat Return a Float or a rounded Integer?\n  // @return [Number] The pseudorandom number, either as a float or integer.\n  static randomRange(min, max, getFloat) {\n    if (getFloat == null) { getFloat = false; }\n    const rand = min + (Math.random() * (max - min));\n    if (getFloat) { return rand.toFixed(getFloat); } else { return Math.round(rand); }\n  }\n\n  // Calculates the luminance of a single pixel using a special weighted sum.\n  // @param [Object] rgba RGBA object describing a single pixel.\n  // @return [Number] The luminance value of the pixel.\n  static luminance(rgba) { return (0.299 * rgba.r) + (0.587 * rgba.g) + (0.114 * rgba.b); }\n\n  // Generates a bezier curve given a start and end point, with control points in between.\n  // Can also optionally bound the y values between a low and high bound.\n  //\n  // This is different than most bezier curve functions because it attempts to construct it in such\n  // a way that we can use it more like a simple input -> output system, or a one-to-one function.\n  // In other words we can provide an input color value, and immediately receive an output modified\n  // color value.\n  //\n  // Note that, by design, this does not force X values to be in the range [0..255]. This is to\n  // generalize the function a bit more. If you give it a starting X value that isn't 0, and/or a\n  // ending X value that isn't 255, you may run into problems with your filter!\n  //\n  // @param [Array] 2-item arrays describing the x, y coordinates of the control points. Minimum two.\n  // @param [Number] lowBound (optional) Minimum possible value for any y-value in the curve.\n  // @param [Number] highBound (optional) Maximum posisble value for any y-value in the curve.\n  // @return [Array] Array whose index represents every x-value between start and end, and value\n  //   represents the corresponding y-value.\n  static bezier(start, ctrl1, ctrl2, end, lowBound, highBound) {\n    //(controlPoints, lowBound, highBound) ->\n    // 4.0 shim - change declaration to (controlPoints, lowBound, highBound) at 5.0\n    let controlPoints;\n    if (lowBound == null) { lowBound = 0; }\n    if (highBound == null) { highBound = 255; }\n    if (start[0] instanceof Array) {\n      controlPoints = start;\n      lowBound = ctrl1;\n      highBound = ctrl2;\n    } else {\n      controlPoints = [start, ctrl1, ctrl2, end];\n    }\n\n    if (controlPoints.length < 2) {\n      throw \"Invalid number of arguments to bezier\";\n    }\n\n    let bezier = {};\n    const lerp = (a, b, t) => (a * (1 - t)) + (b * t);\n    const clamp = (a, min, max) => Math.min(Math.max(a, min), max);\n\n    for (let i = 0; i < 1000; i++) {\n      const t = i / 1000;\n      let prev = controlPoints;\n\n      while (prev.length > 1) {\n        const next = [];\n\n        for (let j = 0, end1 = prev.length - 2, asc = 0 <= end1; asc ? j <= end1 : j >= end1; asc ? j++ : j--) {\n          next.push([\n            lerp(prev[j][0], prev[j + 1][0], t),\n            lerp(prev[j][1], prev[j + 1][1], t)\n          ]);\n        }\n\n        prev = next;\n      }\n\n      bezier[Math.round(prev[0][0])] = Math.round(clamp(prev[0][1], lowBound, highBound));\n    }\n\n    const endX = controlPoints[controlPoints.length - 1][0];\n    bezier = Caman.Calculate.missingValues(bezier, endX);\n\n    // Edge case\n    if ((bezier[endX] == null)) { bezier[endX] = bezier[endX - 1]; }\n\n    return bezier;\n  }\n\n  // Generates a hermite curve given a start and end point, with control points in between.\n  // Can also optionally bound the y values between a low and high bound.\n  //\n  // This is different than most hermite curve functions because it attempts to construct it in such\n  // a way that we can use it more like a simple input -> output system, or a one-to-one function.\n  // In other words we can provide an input color value, and immediately receive an output modified\n  // color value.\n  //\n  // Note that, by design, this does not force X values to be in the range [0..255]. This is to\n  // generalize the function a bit more. If you give it a starting X value that isn't 0, and/or a\n  // ending X value that isn't 255, you may run into problems with your filter!\n  //\n  // @param [Array] 2-item arrays describing the x, y coordinates of the control points. Minimum two.\n  // @param [Number] lowBound (optional) Minimum possible value for any y-value in the curve.\n  // @param [Number] highBound (optional) Maximum possible value for any y-value in the curve.\n  // @return [Array] Array whose index represents every x-value between start and end, and value\n  //   represents the corresponding y-value.\n  static hermite(controlPoints, lowBound, highBound) {\n    if (controlPoints.length < 2) {\n      throw \"Invalid number of arguments to hermite\";\n    }\n\n    let ret = {};\n\n    const lerp = (a, b, t) => (a * (1 - t)) + (b * t);\n    const add = (a, b, c, d) => [a[0] + b[0] + c[0] + d[0], a[1] + b[1] + c[1] + d[1]];\n    const mul = (a, b) => [a[0] * b[0], a[1] * b[1]];\n    const sub = (a, b) => [a[0] - b[0], a[1] - b[1]];\n    const clamp = (a, min, max) => Math.min(Math.max(a, min), max);\n\n    let count = 0;\n    for (let i = 0, end = controlPoints.length - 2, asc = 0 <= end; asc ? i <= end : i >= end; asc ? i++ : i--) {\n      const p0 = controlPoints[i];\n      const p1 = controlPoints[i + 1];\n\n      const pointsPerSegment = p1[0] - p0[0];\n      let pointsPerStep = 1 / pointsPerSegment;\n\n      // the last point of the last segment should reach p1\n      if(i === (controlPoints.length - 2)) {\n        pointsPerStep = 1 / (pointsPerSegment - 1);\n      }\n\n      let p = i > 0 ? controlPoints[i - 1] : p0;\n      const m0 = mul(sub(p1, p), [0.5, 0.5]);\n\n      p = i < (controlPoints.length - 2) ? controlPoints[i + 2] : p1;\n      const m1 = mul(sub(p, p0), [0.5, 0.5]);\n\n      for (let j = 0, end1 = pointsPerSegment, asc1 = 0 <= end1; asc1 ? j <= end1 : j >= end1; asc1 ? j++ : j--) {\n        const t = j * pointsPerStep;\n\n        const fac0 = ((2.0 * t * t * t) - (3.0 * t * t)) + 1.0;\n        const fac1 = ((t * t * t) - (2.0 * t * t)) + t;\n        const fac2 = (-2.0 * t * t * t) + (3.0 * t * t);\n        const fac3 = (t * t * t) - (t * t);\n\n        const pos = add(mul(p0, [fac0, fac0]), mul(m0, [fac1, fac1]), mul(p1, [fac2, fac2]), mul(m1, [fac3, fac3]));\n\n        ret[Math.round(pos[0])] = Math.round(clamp(pos[1], lowBound, highBound));\n\n        count += 1;\n      }\n    }\n\n    // add missing values\n    const endX = controlPoints[controlPoints.length - 1][0];\n    ret = Caman.Calculate.missingValues(ret, endX);\n\n    return ret;\n  }\n\n  // Calculates possible missing values from a given value array. Note that this returns a copy\n  // and does not mutate the original. In case no values are missing the original array is\n  // returned as that is convenient.\n  //\n  // @param [Array] 2-item arrays describing the x, y coordinates of the control points.\n  // @param [Number] end x value of the array (maximum)\n  // @return [Array] Array whose index represents every x-value between start and end, and value\n  //   represents the corresponding y-value.\n  static missingValues(values, endX) {\n    // Do a search for missing values in the bezier array and use linear\n    // interpolation to approximate their values\n    var i, j, leftCoord, ret, rightCoord, _i, _j;\n    if (Object.keys(values).length < endX + 1) {\n      ret = {};\n      for (i = _i = 0; 0 <= endX ? _i <= endX : _i >= endX; i = 0 <= endX ? ++_i : --_i) {\n        if (values[i] != null) {\n          ret[i] = values[i];\n        } else {\n          leftCoord = [i - 1, ret[i - 1]];\n          for (j = _j = i; i <= endX ? _j <= endX : _j >= endX; j = i <= endX ? ++_j : --_j) {\n            if (values[j] != null) {\n              rightCoord = [j, values[j]];\n              break;\n            }\n          }\n\n          if (!rightCoord) {\n            rightCoord = [0,0];\n          }\n\n          ret[i] = leftCoord[1] + ((rightCoord[1] - leftCoord[1]) / (rightCoord[0] - leftCoord[0])) * (i - leftCoord[0]);\n        }\n      }\n      return ret;\n    }\n    return values;\n  }\n}\n\nCaman.Calculate = Calculate;","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\layer.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\filter.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\pixel.js",["543","544","545","546","547","548"],"/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n// Represents a single Pixel in an image.\nclass Pixel {\n  static coordinatesToLocation(x, y, width) {\n    return ((y * width) + x) * 4;\n  }\n\n  static locationToCoordinates(loc, width) {\n    const y = Math.floor(loc / (width * 4));\n    const x = (loc % (width * 4)) / 4;\n\n    return {x, y};\n  }\n\n  constructor(r, g, b, a, c = null) {\n    if (r == null) { r = 0; }\n    this.r = r;\n    if (g == null) { g = 0; }\n    this.g = g;\n    if (b == null) { b = 0; }\n    this.b = b;\n    if (a == null) { a = 255; }\n    this.a = a;\n    this.c = c;\n    this.loc = 0;\n  }\n\n  setContext(c) { return this.c = c; }\n\n  // Retrieves the X, Y location of the current pixel. The origin is at the bottom left corner of\n  // the image, like a normal coordinate system.\n  locationXY() {\n    if (this.c == null) { throw \"Requires a CamanJS context\"; }\n\n    const y = this.c.dimensions.height - Math.floor(this.loc / (this.c.dimensions.width * 4));\n    const x = (this.loc % (this.c.dimensions.width * 4)) / 4;\n\n    return {x, y};\n  }\n\n  pixelAtLocation(loc) {\n    if (this.c == null) { throw \"Requires a CamanJS context\"; }\n\n    return new Pixel(\n      this.c.pixelData[loc],\n      this.c.pixelData[loc + 1],\n      this.c.pixelData[loc + 2],\n      this.c.pixelData[loc + 3],\n      this.c\n    );\n  }\n\n  // Returns an RGBA object for a pixel whose location is specified in relation to the current\n  // pixel.\n  getPixelRelative(horiz, vert) {\n    if (this.c == null) { throw \"Requires a CamanJS context\"; }\n\n    // We invert the vert_offset in order to make the coordinate system non-inverted. In laymans\n    // terms: -1 means down and +1 means up.\n    const newLoc = this.loc + (this.c.dimensions.width * 4 * (vert * -1)) + (4 * horiz);\n\n    if ((newLoc > this.c.pixelData.length) || (newLoc < 0)) {\n      return new Pixel(0, 0, 0, 255, this.c);\n    }\n\n    return this.pixelAtLocation(newLoc);\n  }\n\n  // The counterpart to getPixelRelative, this updates the value of a pixel whose location is\n  // specified in relation to the current pixel.\n  putPixelRelative(horiz, vert, rgba) {\n    if (this.c == null) { throw \"Requires a CamanJS context\"; }\n\n    const nowLoc = this.loc + (this.c.dimensions.width * 4 * (vert * -1)) + (4 * horiz);\n\n    if ((newLoc > this.c.pixelData.length) || (newLoc < 0)) { return; }\n\n    this.c.pixelData[newLoc] = rgba.r;\n    this.c.pixelData[newLoc + 1] = rgba.g;\n    this.c.pixelData[newLoc + 2] = rgba.b;\n    this.c.pixelData[newLoc + 3] = rgba.a;\n\n    return true;\n  }\n\n  // Gets an RGBA object for an arbitrary pixel in the canvas specified by absolute X, Y coordinates\n  getPixel(x, y) {\n    if (this.c == null) { throw \"Requires a CamanJS context\"; }\n\n    const loc = this.coordinatesToLocation(x, y, this.width);\n    return this.pixelAtLocation(loc);\n  }\n\n  // Updates the pixel at the given X, Y coordinate\n  putPixel(x, y, rgba) {\n    if (this.c == null) { throw \"Requires a CamanJS context\"; }\n\n    const loc = this.coordinatesToLocation(x, y, this.width);\n\n    this.c.pixelData[loc] = rgba.r;\n    this.c.pixelData[loc + 1] = rgba.g;\n    this.c.pixelData[loc + 2] = rgba.b;\n    return this.c.pixelData[loc + 3] = rgba.a;\n  }\n\n  toString() { return this.toKey(); }\n  toHex(includeAlpha) {\n    if (includeAlpha == null) { includeAlpha = false; }\n    const hex = '#' +\n      this.r.toString(16) +\n      this.g.toString(16) +\n      this.b.toString(16);\n\n    if (includeAlpha) { return hex + this.a.toString(16); } else { return hex; }\n  }\n}\n\nCaman.Pixel = Pixel;","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\event.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\io.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\plugin.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\lib\\blenders.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\lib\\filters.js",["549","550","551","552"],"Caman.Filter.register(\"fillColor\", function () {\n  var color;\n  if (arguments.length === 1) {\n    color = Caman.Convert.hexToRGB(arguments[0]);\n  } else {\n    color = {\n      r: arguments[0],\n      g: arguments[1],\n      b: arguments[2]\n    };\n  }\n  return this.process(\"fillColor\", function (rgba) {\n    rgba.r = color.r;\n    rgba.g = color.g;\n    rgba.b = color.b;\n    rgba.a = 255;\n    return rgba;\n  });\n});\n\nCaman.Filter.register(\"brightness\", function (adjust) {\n  adjust = Math.floor(255 * (adjust / 100));\n  return this.process(\"brightness\", function (rgba) {\n    rgba.r += adjust;\n    rgba.g += adjust;\n    rgba.b += adjust;\n    return rgba;\n  });\n});\n\nCaman.Filter.register(\"saturation\", function (adjust) {\n  adjust *= -0.01;\n  return this.process(\"saturation\", function (rgba) {\n    var max;\n    max = Math.max(rgba.r, rgba.g, rgba.b);\n    if (rgba.r !== max) {\n      rgba.r += (max - rgba.r) * adjust;\n    }\n    if (rgba.g !== max) {\n      rgba.g += (max - rgba.g) * adjust;\n    }\n    if (rgba.b !== max) {\n      rgba.b += (max - rgba.b) * adjust;\n    }\n    return rgba;\n  });\n});\n\nCaman.Filter.register(\"vibrance\", function (adjust) {\n  adjust *= -1;\n  return this.process(\"vibrance\", function (rgba) {\n    var amt, avg, max;\n    max = Math.max(rgba.r, rgba.g, rgba.b);\n    avg = (rgba.r + rgba.g + rgba.b) / 3;\n    amt = ((Math.abs(max - avg) * 2 / 255) * adjust) / 100;\n    if (rgba.r !== max) {\n      rgba.r += (max - rgba.r) * amt;\n    }\n    if (rgba.g !== max) {\n      rgba.g += (max - rgba.g) * amt;\n    }\n    if (rgba.b !== max) {\n      rgba.b += (max - rgba.b) * amt;\n    }\n    return rgba;\n  });\n});\n\nCaman.Filter.register(\"greyscale\", function (adjust) {\n  return this.process(\"greyscale\", function (rgba) {\n    var avg;\n    avg = Caman.Calculate.luminance(rgba);\n    rgba.r = avg;\n    rgba.g = avg;\n    rgba.b = avg;\n    return rgba;\n  });\n});\n\nCaman.Filter.register(\"contrast\", function (adjust) {\n  adjust = Math.pow((adjust + 100) / 100, 2);\n  return this.process(\"contrast\", function (rgba) {\n    rgba.r /= 255;\n    rgba.r -= 0.5;\n    rgba.r *= adjust;\n    rgba.r += 0.5;\n    rgba.r *= 255;\n    rgba.g /= 255;\n    rgba.g -= 0.5;\n    rgba.g *= adjust;\n    rgba.g += 0.5;\n    rgba.g *= 255;\n    rgba.b /= 255;\n    rgba.b -= 0.5;\n    rgba.b *= adjust;\n    rgba.b += 0.5;\n    rgba.b *= 255;\n    return rgba;\n  });\n});\n\nCaman.Filter.register(\"hue\", function (adjust) {\n  return this.process(\"hue\", function (rgba) {\n    var b, g, h, hsv, r, _ref;\n    hsv = Caman.Convert.rgbToHSV(rgba.r, rgba.g, rgba.b);\n    h = hsv.h * 100;\n    h += Math.abs(adjust);\n    h = h % 100;\n    h /= 100;\n    hsv.h = h;\n    _ref = Caman.Convert.hsvToRGB(hsv.h, hsv.s, hsv.v), r = _ref.r, g = _ref.g, b = _ref.b;\n    rgba.r = r;\n    rgba.g = g;\n    rgba.b = b;\n    return rgba;\n  });\n});\n\nCaman.Filter.register(\"colorize\", function () {\n  var level, rgb;\n  if (arguments.length === 2) {\n    rgb = Caman.Convert.hexToRGB(arguments[0]);\n    level = arguments[1];\n  } else if (arguments.length === 4) {\n    rgb = {\n      r: arguments[0],\n      g: arguments[1],\n      b: arguments[2]\n    };\n    level = arguments[3];\n  }\n  return this.process(\"colorize\", function (rgba) {\n    rgba.r -= (rgba.r - rgb.r) * (level / 100);\n    rgba.g -= (rgba.g - rgb.g) * (level / 100);\n    rgba.b -= (rgba.b - rgb.b) * (level / 100);\n    return rgba;\n  });\n});\n\nCaman.Filter.register(\"invert\", function () {\n  return this.process(\"invert\", function (rgba) {\n    rgba.r = 255 - rgba.r;\n    rgba.g = 255 - rgba.g;\n    rgba.b = 255 - rgba.b;\n    return rgba;\n  });\n});\n\nCaman.Filter.register(\"sepia\", function (adjust) {\n  if (adjust == null) {\n    adjust = 100;\n  }\n  adjust /= 100;\n  return this.process(\"sepia\", function (rgba) {\n    rgba.r = Math.min(255, (rgba.r * (1 - (0.607 * adjust))) + (rgba.g * (0.769 * adjust)) + (rgba.b * (0.189 * adjust)));\n    rgba.g = Math.min(255, (rgba.r * (0.349 * adjust)) + (rgba.g * (1 - (0.314 * adjust))) + (rgba.b * (0.168 * adjust)));\n    rgba.b = Math.min(255, (rgba.r * (0.272 * adjust)) + (rgba.g * (0.534 * adjust)) + (rgba.b * (1 - (0.869 * adjust))));\n    return rgba;\n  });\n});\n\nCaman.Filter.register(\"gamma\", function (adjust) {\n  return this.process(\"gamma\", function (rgba) {\n    rgba.r = Math.pow(rgba.r / 255, adjust) * 255;\n    rgba.g = Math.pow(rgba.g / 255, adjust) * 255;\n    rgba.b = Math.pow(rgba.b / 255, adjust) * 255;\n    return rgba;\n  });\n});\n\nCaman.Filter.register(\"noise\", function (adjust) {\n  adjust = Math.abs(adjust) * 2.55;\n  return this.process(\"noise\", function (rgba) {\n    var rand;\n    rand = Caman.Calculate.randomRange(adjust * -1, adjust);\n    rgba.r += rand;\n    rgba.g += rand;\n    rgba.b += rand;\n    return rgba;\n  });\n});\n\nCaman.Filter.register(\"clip\", function (adjust) {\n  adjust = Math.abs(adjust) * 2.55;\n  return this.process(\"clip\", function (rgba) {\n    if (rgba.r > 255 - adjust) {\n      rgba.r = 255;\n    } else if (rgba.r < adjust) {\n      rgba.r = 0;\n    }\n    if (rgba.g > 255 - adjust) {\n      rgba.g = 255;\n    } else if (rgba.g < adjust) {\n      rgba.g = 0;\n    }\n    if (rgba.b > 255 - adjust) {\n      rgba.b = 255;\n    } else if (rgba.b < adjust) {\n      rgba.b = 0;\n    }\n    return rgba;\n  });\n});\n\nCaman.Filter.register(\"channels\", function (options) {\n  var chan, value;\n  if (typeof options !== \"object\") {\n    return this;\n  }\n  for (chan in options) {\n    if (!{}.hasOwnProperty.call(options, chan)) continue;\n    value = options[chan];\n    if (value === 0) {\n      delete options[chan];\n      continue;\n    }\n    options[chan] /= 100;\n  }\n  if (options.length === 0) {\n    return this;\n  }\n  return this.process(\"channels\", function (rgba) {\n    if (options.red != null) {\n      if (options.red > 0) {\n        rgba.r += (255 - rgba.r) * options.red;\n      } else {\n        rgba.r -= rgba.r * Math.abs(options.red);\n      }\n    }\n    if (options.green != null) {\n      if (options.green > 0) {\n        rgba.g += (255 - rgba.g) * options.green;\n      } else {\n        rgba.g -= rgba.g * Math.abs(options.green);\n      }\n    }\n    if (options.blue != null) {\n      if (options.blue > 0) {\n        rgba.b += (255 - rgba.b) * options.blue;\n      } else {\n        rgba.b -= rgba.b * Math.abs(options.blue);\n      }\n    }\n    return rgba;\n  });\n});\n\nCaman.Filter.register(\"curves\", function () {\n  var algo, bezier, chans, cps, end, i, last, start, _i, _j, _ref, _ref1;\n  chans = arguments[0], cps = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];\n  last = cps[cps.length - 1];\n  if (typeof last === \"function\") {\n    algo = last;\n    cps.pop();\n  } else if (typeof last === \"string\") {\n    algo = Caman.Calculate[last];\n    cps.pop();\n  } else {\n    algo = Caman.Calculate.bezier;\n  }\n  if (typeof chans === \"string\") {\n    chans = chans.split(\"\");\n  }\n  if (chans[0] === \"v\") {\n    chans = ['r', 'g', 'b'];\n  }\n  if (cps.length < 2) {\n    throw \"Invalid number of arguments to curves filter\";\n  }\n  bezier = algo(cps, 0, 255);\n  start = cps[0];\n  if (start[0] > 0) {\n    for (i = _i = 0, _ref = start[0]; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n      bezier[i] = start[1];\n    }\n  }\n  end = cps[cps.length - 1];\n  if (end[0] < 255) {\n    for (i = _j = _ref1 = end[0]; _ref1 <= 255 ? _j <= 255 : _j >= 255; i = _ref1 <= 255 ? ++_j : --_j) {\n      bezier[i] = end[1];\n    }\n  }\n  return this.process(\"curves\", function (rgba) {\n    var _k, _ref2;\n    for (i = _k = 0, _ref2 = chans.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {\n      rgba[chans[i]] = bezier[rgba[chans[i]]];\n    }\n    return rgba;\n  });\n});\n\nCaman.Filter.register(\"exposure\", function (adjust) {\n  var ctrl1, ctrl2, p;\n  p = Math.abs(adjust) / 100;\n  ctrl1 = [0, 255 * p];\n  ctrl2 = [255 - (255 * p), 255];\n  if (adjust < 0) {\n    ctrl1 = ctrl1.reverse();\n    ctrl2 = ctrl2.reverse();\n  }\n  return this.curves('rgb', [0, 0], ctrl1, ctrl2, [255, 255]);\n});\n","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\rotate.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\flip.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\lib\\size.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\stackBlur.js",["553"],"/*\n  StackBlur - a fast almost Gaussian Blur For Canvas v0.31 modified for CamanJS\n\n  Version:   0.31\n  Author:    Mario Klingemann\n  Contact:   mario@quasimondo.com\n  Website:  http://www.quasimondo.com/StackBlurForCanvas\n  Twitter:  @quasimondo\n  Modified By: Ryan LeFevre (@meltingice)\n\n  In case you find this class useful - especially in commercial projects -\n  I am not totally unhappy for a small donation to my PayPal account\n  mario@quasimondo.de\n\n  Or support me on flattr:\n  https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript\n\n  Copyright (c) 2010 Mario Klingemann\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation\n  files (the \"Software\"), to deal in the Software without\n  restriction, including without limitation the rights to use,\n  copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the\n  Software is furnished to do so, subject to the following\n  conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n  OTHER DEALINGS IN THE SOFTWARE.\n  */\n\n\nvar BlurStack, mul_table, shg_table;\nmul_table = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];\nshg_table = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];\nBlurStack = function () {\n  this.r = 0;\n  this.g = 0;\n  this.b = 0;\n  this.a = 0;\n  return this.next = null;\n};\nCaman.Plugin.register(\"stackBlur\", function (radius) {\n  var b_in_sum, b_out_sum, b_sum, div, g_in_sum, g_out_sum, g_sum, height, heightMinus1, i, mul_sum, p, pb, pg,\n    pixels, pr, r_in_sum, r_out_sum, r_sum, radiusPlus1, rbs, shg_sum, stack, stackEnd, stackIn, stackOut, stackStart,\n    sumFactor, w4, width, widthMinus1, x, y, yi, yp, yw, _i, _j, _k, _l, _m, _n, _o, _p, _q;\n  if (isNaN(radius) || radius < 1) {\n    return;\n  }\n  radius |= 0;\n  pixels = this.pixelData;\n  width = this.dimensions.width;\n  height = this.dimensions.height;\n  div = radius + radius + 1;\n  w4 = width << 2;\n  widthMinus1 = width - 1;\n  heightMinus1 = height - 1;\n  radiusPlus1 = radius + 1;\n  sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;\n  stackStart = new BlurStack();\n  stack = stackStart;\n  for (i = _i = 1; 1 <= div ? _i < div : _i > div; i = 1 <= div ? ++_i : --_i) {\n    stack = stack.next = new BlurStack();\n    if (i === radiusPlus1) {\n      stackEnd = stack;\n    }\n  }\n  stack.next = stackStart;\n  stackIn = null;\n  stackOut = null;\n  yw = yi = 0;\n  mul_sum = mul_table[radius];\n  shg_sum = shg_table[radius];\n  for (y = _j = 0; 0 <= height ? _j < height : _j > height; y = 0 <= height ? ++_j : --_j) {\n    r_in_sum = g_in_sum = b_in_sum = r_sum = g_sum = b_sum = 0;\n    r_out_sum = radiusPlus1 * (pr = pixels[yi]);\n    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);\n    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);\n    r_sum += sumFactor * pr;\n    g_sum += sumFactor * pg;\n    b_sum += sumFactor * pb;\n    stack = stackStart;\n    for (i = _k = 0; 0 <= radiusPlus1 ? _k < radiusPlus1 : _k > radiusPlus1; i = 0 <= radiusPlus1 ? ++_k : --_k) {\n      stack.r = pr;\n      stack.g = pg;\n      stack.b = pb;\n      stack = stack.next;\n    }\n    for (i = _l = 1; 1 <= radiusPlus1 ? _l < radiusPlus1 : _l > radiusPlus1; i = 1 <= radiusPlus1 ? ++_l : --_l) {\n      p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);\n      r_sum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);\n      g_sum += (stack.g = (pg = pixels[p + 1])) * rbs;\n      b_sum += (stack.b = (pb = pixels[p + 2])) * rbs;\n      r_in_sum += pr;\n      g_in_sum += pg;\n      b_in_sum += pb;\n      stack = stack.next;\n    }\n    stackIn = stackStart;\n    stackOut = stackEnd;\n    for (x = _m = 0; 0 <= width ? _m < width : _m > width; x = 0 <= width ? ++_m : --_m) {\n      pixels[yi] = (r_sum * mul_sum) >> shg_sum;\n      pixels[yi + 1] = (g_sum * mul_sum) >> shg_sum;\n      pixels[yi + 2] = (b_sum * mul_sum) >> shg_sum;\n      r_sum -= r_out_sum;\n      g_sum -= g_out_sum;\n      b_sum -= b_out_sum;\n      r_out_sum -= stackIn.r;\n      g_out_sum -= stackIn.g;\n      b_out_sum -= stackIn.b;\n      p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;\n      r_in_sum += (stackIn.r = pixels[p]);\n      g_in_sum += (stackIn.g = pixels[p + 1]);\n      b_in_sum += (stackIn.b = pixels[p + 2]);\n      r_sum += r_in_sum;\n      g_sum += g_in_sum;\n      b_sum += b_in_sum;\n      stackIn = stackIn.next;\n      r_out_sum += (pr = stackOut.r);\n      g_out_sum += (pg = stackOut.g);\n      b_out_sum += (pb = stackOut.b);\n      r_in_sum -= pr;\n      g_in_sum -= pg;\n      b_in_sum -= pb;\n      stackOut = stackOut.next;\n      yi += 4;\n    }\n    yw += width;\n  }\n  for (x = _n = 0; 0 <= width ? _n < width : _n > width; x = 0 <= width ? ++_n : --_n) {\n    g_in_sum = b_in_sum = r_in_sum = g_sum = b_sum = r_sum = 0;\n    yi = x << 2;\n    r_out_sum = radiusPlus1 * (pr = pixels[yi]);\n    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);\n    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);\n    r_sum += sumFactor * pr;\n    g_sum += sumFactor * pg;\n    b_sum += sumFactor * pb;\n    stack = stackStart;\n    for (i = _o = 0; 0 <= radiusPlus1 ? _o < radiusPlus1 : _o > radiusPlus1; i = 0 <= radiusPlus1 ? ++_o : --_o) {\n      stack.r = pr;\n      stack.g = pg;\n      stack.b = pb;\n      stack = stack.next;\n    }\n    yp = width;\n    for (i = _p = 1; 1 <= radius ? _p <= radius : _p >= radius; i = 1 <= radius ? ++_p : --_p) {\n      yi = (yp + x) << 2;\n      r_sum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);\n      g_sum += (stack.g = (pg = pixels[yi + 1])) * rbs;\n      b_sum += (stack.b = (pb = pixels[yi + 2])) * rbs;\n      r_in_sum += pr;\n      g_in_sum += pg;\n      b_in_sum += pb;\n      stack = stack.next;\n      if (i < heightMinus1) {\n        yp += width;\n      }\n    }\n    yi = x;\n    stackIn = stackStart;\n    stackOut = stackEnd;\n    for (y = _q = 0; 0 <= height ? _q < height : _q > height; y = 0 <= height ? ++_q : --_q) {\n      p = yi << 2;\n      pixels[p] = (r_sum * mul_sum) >> shg_sum;\n      pixels[p + 1] = (g_sum * mul_sum) >> shg_sum;\n      pixels[p + 2] = (b_sum * mul_sum) >> shg_sum;\n      r_sum -= r_out_sum;\n      g_sum -= g_out_sum;\n      b_sum -= b_out_sum;\n      r_out_sum -= stackIn.r;\n      g_out_sum -= stackIn.g;\n      b_out_sum -= stackIn.b;\n      p = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width)) << 2;\n      r_sum += (r_in_sum += (stackIn.r = pixels[p]));\n      g_sum += (g_in_sum += (stackIn.g = pixels[p + 1]));\n      b_sum += (b_in_sum += (stackIn.b = pixels[p + 2]));\n      stackIn = stackIn.next;\n      r_out_sum += (pr = stackOut.r);\n      g_out_sum += (pg = stackOut.g);\n      b_out_sum += (pb = stackOut.b);\n      r_in_sum -= pr;\n      g_in_sum -= pg;\n      b_in_sum -= pb;\n      stackOut = stackOut.next;\n      yi += width;\n    }\n  }\n  return this;\n});\n\nCaman.Filter.register(\"stackBlur\", function (radius) {\n  return this.processPlugin(\"stackBlur\", [radius]);\n});","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\common\\posterize.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\common\\vignette.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\common\\blur.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\effects\\edges.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\effects\\grungy.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\effects\\hazyDays.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\effects\\lomo.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\effects\\compoundBlur.js",["554"],"import { Util } from '../../core/util';\n\n/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS202: Simplify dynamic range loops\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n/*\nCompoundBlur - Blurring with varying radii for Canvas\n\nVersion:   0.1\nAuthor:  Mario Klingemann\nContact:   mario@quasimondo.com\nWebsite:  http://www.quasimondo.com/StackBlurForCanvas\nTwitter:  @quasimondo\nModified By: Ryan LeFevre (@meltingice)\n\nIn case you find this class useful - especially in commercial projects -\nI am not totally unhappy for a small donation to my PayPal account\nmario@quasimondo.de\n\nCopyright (c) 2011 Mario Klingemann\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\n// Wrapping this in a closure since there's a bunch of extra functions this plugin requires\n// and we don't want them clogging up the global scope.\n(function() {\n  const mul_table = [\n    512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];\n\n\n  const shg_table = [\n    9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];\n\n  const getLinearGradientMap = function(width, height, centerX, centerY, angle, length, mirrored) {\n    const cnv = document.createElement('canvas');\n    cnv.width = width;\n    cnv.height = height;\n\n    const x1 = centerX + (Math.cos(angle) * length * 0.5);\n    const y1 = centerY + (Math.sin(angle) * length * 0.5);\n\n    const x2 = centerX - (Math.cos(angle) * length * 0.5);\n    const y2 = centerY - (Math.sin(angle) * length * 0.5);\n\n    const context = cnv.getContext(\"2d\");\n    const gradient = context.createLinearGradient(x1, y1, x2, y2);\n    if (!mirrored) {\n      gradient.addColorStop(0, \"white\");\n      gradient.addColorStop(1, \"black\");\n    } else {\n      gradient.addColorStop(0, \"white\");\n      gradient.addColorStop(0.5, \"black\");\n      gradient.addColorStop(1, \"white\");\n    }\n\n    context.fillStyle = gradient;\n    context.fillRect(0, 0, width, height);\n    return context.getImageData(0, 0, width, height);\n  };\n\n  const getRadialGradientMap = function(width, height, centerX, centerY, radius1, radius2) {\n    const cnv = document.createElement('canvas');\n    cnv.width = width;\n    cnv.height = height;\n\n    const context = cnv.getContext(\"2d\");\n    const gradient = context.createRadialGradient(centerX, centerY, radius1, centerX, centerY, radius2);\n\n    gradient.addColorStop(1, \"white\");\n    gradient.addColorStop(0, \"black\");\n\n    context.fillStyle = gradient;\n    context.fillRect(0, 0, width, height);\n    return context.getImageData(0, 0, width, height);\n  };\n\n  const BlurStack = function() {\n    this.r = 0;\n    this.g = 0;\n    this.b = 0;\n    this.a = 0;\n    return this.next = null;\n  };\n\n  Caman.Plugin.register(\"compoundBlur\", function(radiusData, radius, increaseFactor, blurLevels) {\n    let i;\n    let asc, end;\n    const { width } = this.dimensions;\n    const { height } = this.dimensions;\n\n    const imagePixels = this.pixelData;\n    const radiusPixels = radiusData.data;\n\n    const wh = width * height;\n    const wh4 = wh << 2;\n    const pixels = [];\n\n    for (i = 0, end = wh4, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) { pixels[i] = imagePixels[i]; }\n\n    let currentIndex = 0;\n    let steps = blurLevels;\n    blurLevels -= 1;\n\n    while (steps-- >= 0) {\n      var asc1, end1;\n      var b_in_sum, b_out_sum, b_sum, g_in_sum, g_out_sum, g_sum, p, pb, pg, pr, r_in_sum, r_out_sum, r_sum, rbs, x, y, yi;\n      var asc2, end2;\n      var asc6, end6;\n      let iradius = (radius + 0.5) | 0;\n      if (iradius === 0) { continue; }\n      if (iradius > 256) { iradius = 256; }\n\n      const div = iradius + iradius + 1;\n      const w4 = width << 2;\n      const widthMinus1 = width - 1;\n      const heightMinus1 = height - 1;\n      const radiusPlus1 = iradius + 1;\n      const sumFactor = (radiusPlus1 * (radiusPlus1 + 1)) / 2;\n\n      const stackStart = new BlurStack();\n      let stackEnd = undefined;\n      let stack = stackStart;\n\n      for (i = 1, end1 = div, asc1 = 1 <= end1; asc1 ? i < end1 : i > end1; asc1 ? i++ : i--) {\n        stack = (stack.next = new BlurStack());\n        if (i === radiusPlus1) { stackEnd = stack; }\n      }\n\n      stack.next = stackStart;\n      let stackIn = null;\n      let stackOut = null;\n\n      let yw = (yi = 0);\n\n      const mul_sum = mul_table[iradius];\n      const shg_sum = shg_table[iradius];\n\n      for (y = 0, end2 = height, asc2 = 0 <= end2; asc2 ? y < end2 : y > end2; asc2 ? y++ : y--) {\n        var asc3, end3;\n        var asc4, end4;\n        var asc5, end5;\n        r_in_sum = (g_in_sum = (b_in_sum = (r_sum = (g_sum = (b_sum = 0)))));\n\n        r_out_sum = radiusPlus1 * (pr = pixels[yi]);\n        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);\n        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);\n\n        r_sum += sumFactor * pr;\n        g_sum += sumFactor * pg;\n        b_sum += sumFactor * pb;\n\n        stack = stackStart;\n\n        for (i = 0, end3 = radiusPlus1, asc3 = 0 <= end3; asc3 ? i < end3 : i > end3; asc3 ? i++ : i--) {\n          stack.r = pr;\n          stack.g = pg;\n          stack.b = pb;\n          stack = stack.next;\n        }\n\n        for (i = 1, end4 = radiusPlus1, asc4 = 1 <= end4; asc4 ? i < end4 : i > end4; asc4 ? i++ : i--) {\n          p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);\n          r_sum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);\n          g_sum += (stack.g = (pg = pixels[p + 1])) * rbs;\n          b_sum += (stack.b = (pb = pixels[p + 2])) * rbs;\n\n          r_in_sum += pr;\n          g_in_sum += pg;\n          b_in_sum += pb;\n\n          stack = stack.next;\n        }\n\n        stackIn = stackStart;\n        stackOut = stackEnd;\n\n        for (x = 0, end5 = width, asc5 = 0 <= end5; asc5 ? x < end5 : x > end5; asc5 ? x++ : x--) {\n          pixels[yi] = (r_sum * mul_sum) >> shg_sum;\n          pixels[yi + 1] = (g_sum * mul_sum) >> shg_sum;\n          pixels[yi + 2] = (b_sum * mul_sum) >> shg_sum;\n\n          r_sum -= r_out_sum;\n          g_sum -= g_out_sum;\n          b_sum -= b_out_sum;\n\n          r_out_sum -= stackIn.r;\n          g_out_sum -= stackIn.g;\n          b_out_sum -= stackIn.b;\n\n          p = (yw + ((p = x + radiusPlus1) < widthMinus1 ? p : widthMinus1)) << 2;\n\n          r_in_sum += (stackIn.r = pixels[p]);\n          g_in_sum += (stackIn.g = pixels[p + 1]);\n          b_in_sum += (stackIn.b = pixels[p + 2]);\n\n          r_sum += r_in_sum;\n          g_sum += g_in_sum;\n          b_sum += b_in_sum;\n\n          stackIn = stackIn.next;\n\n          r_out_sum += (pr = stackOut.r);\n          g_out_sum += (pg = stackOut.g);\n          b_out_sum += (pb = stackOut.b);\n\n          r_in_sum -= pr;\n          g_in_sum -= pg;\n          b_in_sum -= pb;\n\n          stackOut = stackOut.next;\n\n          yi += 4;\n        }\n\n        yw += width;\n      }\n\n      for (x = 0, end6 = width, asc6 = 0 <= end6; asc6 ? x < end6 : x > end6; asc6 ? x++ : x--) {\n        var asc7, end7;\n        var asc8, end8;\n        var asc9, end9;\n        g_in_sum = (b_in_sum = (r_in_sum = (g_sum = (b_sum = (r_sum = 0)))));\n\n        yi = x << 2;\n        r_out_sum = radiusPlus1 * (pr = pixels[yi]);\n        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);\n        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);\n\n        r_sum += sumFactor * pr;\n        g_sum += sumFactor * pg;\n        b_sum += sumFactor * pb;\n\n        stack = stackStart;\n\n        for (i = 0, end7 = radiusPlus1, asc7 = 0 <= end7; asc7 ? i < end7 : i > end7; asc7 ? i++ : i--) {\n          stack.r = pr;\n          stack.g = pg;\n          stack.b = pb;\n          stack = stack.next;\n        }\n\n        let yp = width;\n\n        for (i = 1, end8 = radiusPlus1, asc8 = 1 <= end8; asc8 ? i < end8 : i > end8; asc8 ? i++ : i--) {\n          yi = (yp + x) << 2;\n          r_sum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);\n          g_sum += (stack.g = (pg = pixels[yi + 1])) * rbs;\n          b_sum += (stack.b = (pb = pixels[yi + 2])) * rbs;\n          r_in_sum += pr;\n          g_in_sum += pg;\n          b_in_sum += pb;\n          stack = stack.next;\n          if (i < heightMinus1) { yp += width; }\n        }\n\n        yi = x;\n        stackIn = stackStart;\n        stackOut = stackEnd;\n\n        for (y = 0, end9 = height, asc9 = 0 <= end9; asc9 ? y < end9 : y > end9; asc9 ? y++ : y--) {\n          p = yi << 2;\n          pixels[p] = (r_sum * mul_sum) >> shg_sum;\n          pixels[p + 1] = (g_sum * mul_sum) >> shg_sum;\n          pixels[p + 2] = (b_sum * mul_sum) >> shg_sum;\n\n          r_sum -= r_out_sum;\n          g_sum -= g_out_sum;\n          b_sum -= b_out_sum;\n\n          r_out_sum -= stackIn.r;\n          g_out_sum -= stackIn.g;\n          b_out_sum -= stackIn.b;\n\n          p = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width)) << 2;\n\n          r_sum += (r_in_sum += (stackIn.r = pixels[p]));\n          g_sum += (g_in_sum += (stackIn.g = pixels[p + 1]));\n          b_sum += (b_in_sum += (stackIn.b = pixels[p + 2]));\n\n          stackIn = stackIn.next;\n\n          r_out_sum += (pr = stackOut.r);\n          g_out_sum += (pg = stackOut.g);\n          b_out_sum += (pb = stackOut.b);\n\n          r_in_sum -= pr;\n          g_in_sum -= pg;\n          b_in_sum -= pb;\n\n          stackOut = stackOut.next;\n\n          yi += width;\n        }\n      }\n\n      radius *= increaseFactor;\n\n      i = wh;\n      while (--i > -1) {\n        const idx = i << 2;\n        const lookupValue = ((radiusPixels[idx + 2] & 0xff) / 255.0) * blurLevels;\n        const index = lookupValue | 0;\n\n        if (index === currentIndex) {\n          const blend = 256.0 * (lookupValue - (lookupValue | 0));\n          const iblend = 256 - blend;\n\n          imagePixels[idx] = ((imagePixels[idx] * iblend) + (pixels[idx] * blend)) >> 8;\n          imagePixels[idx + 1] = ((imagePixels[idx + 1] * iblend) + (pixels[idx + 1] * blend)) >> 8;\n          imagePixels[idx + 2] = ((imagePixels[idx + 2] * iblend) + (pixels[idx + 2] * blend)) >> 8;\n        } else if (index === (currentIndex + 1)) {\n          imagePixels[idx] = pixels[idx];\n          imagePixels[idx + 1] = pixels[idx + 1];\n          imagePixels[idx + 2] = pixels[idx + 2];\n        }\n      }\n      currentIndex++;\n    }\n\n    return this;\n  });\n\n  Caman.Filter.register(\"tiltShift\", function(opts) {\n    const defaults = {\n      center: {\n        x: this.dimensions.width / 2,\n        y: this.dimensions.height / 2\n      },\n      angle: 45,\n      focusWidth: 200,\n      startRadius: 3,\n      radiusFactor: 1.5,\n      steps: 3\n    };\n\n    opts = Util.extend(defaults, opts);\n    opts.angle *= Math.PI / 180;\n    const gradient = getLinearGradientMap(this.dimensions.width, this.dimensions.height, opts.center.x, opts.center.y, opts.angle, opts.focusWidth, true);\n\n    return this.processPlugin(\"compoundBlur\", [gradient, opts.startRadius, opts.radiusFactor, opts.steps]);\n  });\n\n  return Caman.Filter.register(\"radialBlur\", function(opts) {\n    const defaults = {\n      size: 50,\n      center: {\n        x: this.dimensions.width / 2,\n        y: this.dimensions.height / 2\n      },\n      startRadius: 3,\n      radiusFactor: 1.5,\n      steps: 3,\n      radius: null\n    };\n\n    opts = Util.extend(defaults, opts);\n\n    if (!opts.radius) {\n      opts.radius = this.dimensions.width < this.dimensions.height ? this.dimensions.height : this.dimensions.width;\n    }\n\n    const radius1 = (opts.radius / 2) - opts.size;\n    const radius2 = (opts.radius / 2);\n\n    const gradient = getRadialGradientMap(this.dimensions.width, this.dimensions.height, opts.center.x, opts.center.y, radius1, radius2);\n\n    return this.processPlugin(\"compoundBlur\", [gradient, opts.startRadius, opts.radiusFactor, opts.steps]);\n  });\n})();\n          ","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\filters\\crossProcess.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\effects\\sinCity.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\filters\\glowingSun.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\filters\\love.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\filters\\oldBoot.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\filters\\jarques.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\filters\\orangePeel.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\filters\\pinhole.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\filters\\sunrise.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\plugins\\filters\\vintage.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\full-screen-handle.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\CustomizedCanvas.js",["555","556","557","558"],"import React, { Component, createRef } from 'react';\nimport { PreviewCanvas } from '../styledComponents';\nimport { getWatermarkSquaredPosition } from '../utils';\nimport { PREVIEW_CANVAS_ID, SHAPES_VARIANTS, WATERMARK_UNIQUE_KEY } from '../config';\nimport '../utils/canvas-round';\n\n\nexport default class CustomizedCanvas extends Component {\n  _canvas;\n  _context;\n  _initArgs = {\n    hidden: false,\n  };\n  _allowedTabs = [\n    'shapes',\n    'image',\n    'text',\n    'watermark'\n  ]\n\n  constructor(props) {\n    super(props);\n\n    this.canvasRef = createRef();\n    this.shapeResizingBoxRef = createRef();\n\n    this.state = {\n      resizeControlTarget: null,\n      latestCanvasSize: null\n    }\n  }\n\n  componentDidMount() {\n    if (this.canvasRef && this.canvasRef.current && !this._canvas) {\n      this._canvas = this.canvasRef.current;\n      this._canvas.addEventListener('mousedown', this.onSelect);\n      this._context = this._canvas.getContext('2d');\n\n      const border = `1px solid ${\n        this.props.theme?.colors?.text || (this.props.colorScheme === 'light' ? '#000' : '#fff')\n      }`;\n      const availableShapes = [\n        {\n          label: 'Rectangle',\n          variant: SHAPES_VARIANTS.RECT,\n          iconStyles: { height: 50, width: 100, border },\n          drawFn: this.addRect,\n        },\n        {\n          label: 'Square',\n          variant: SHAPES_VARIANTS.SQUARE,\n          iconStyles: { border },\n          drawFn: (props) => this.addSquare({ width: 75, height: 75, ...props }),\n          // iconUrl: undefined,\n        },\n        {\n          label: 'Circle',\n          variant: SHAPES_VARIANTS.CIRCLE,\n          iconStyles: { border, borderRadius: '50%' },\n          drawFn: this.addCircle\n          // iconUrl: undefined,\n        },\n      ]\n\n      this.props.updateState({\n        shapeOperations: {\n          addImage: this.addImage,\n          addRect: this.addRect,\n          addCircle: this.addCircle,\n          addText: this.addText,\n          addOrUpdate: this.addAnyShape,\n          updateShape: this.updateShape,\n          updateShapes: this.updateShapes,\n          replaceAllShapes: this.replaceAllShapes,\n          deleteShape: this.deleteShapeByKeyOrIndex,\n          deleteShapes: this.deleteAllShapesOrByTypeOrIndicies,\n          setShapeVisibility: this.setShapeVisibilityByKeyOrIndex,\n          getShape: this.getShapeByKeyOrIndex,\n          getShapesIndicies: this.getShapesIndexByAnyProp,\n          prepareFinalCanvas: this.prepareFinalCanvas\n        },\n        availableShapes\n      });\n    }\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    return { ...state, latestCanvasSize: props.latestCanvasSize || { width: 0, height: 0 } };\n  }\n\n  componentWillUnmount() {\n    this._canvas.removeEventListener('mousedown', this.onSelect);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.width !== this.props.width || prevProps.height !== this.props.height) {\n      this.redrawShape()\n    }\n  }\n\n  prepareFinalCanvas = (originalCanvasDimensions) => {\n    const { width, height } = originalCanvasDimensions;\n    const { shapes } = this.props;\n    const newCanvas = document.createElement('canvas');\n    newCanvas.width = width;\n    newCanvas.height = height;\n\n    this._canvas.parentNode.insertBefore(newCanvas, this._canvas);\n\n    const oldCanvas = this._canvas;\n\n    this._canvas = newCanvas;\n    this._context = newCanvas.getContext('2d');\n\n    shapes.map((shape) => {\n      // Mapping both (X & WIDTH), (Y & HEIGHT) of shape from old to new canvas with final dimnesions.\n      shape.x = shape.x.mapNumber(0, oldCanvas.width, 0, width);\n      shape.y = shape.y.mapNumber(0, oldCanvas.height, 0, height);\n      \n      if (shape.variant !== SHAPES_VARIANTS.TEXT) {\n        shape.width = shape.width.mapNumber(0, oldCanvas.width, 0, width);\n        shape.height = shape.height.mapNumber(0, oldCanvas.height, 0, height);\n      } else {\n        shape.textSize = parseInt(shape.textSize).mapNumber(0, oldCanvas.width, 0, width);\n      }\n\n      this.drawShapeThroughVariant(shape);\n    });\n\n    return this._canvas;\n  }\n\n  updateState = (data, callback = () => {}) => {\n    const { updateState } = this.props;\n    updateState(data, callback);\n  }\n\n  pushShapeToShapes = (newShape, otherStates) => {\n    const { shapes } = this.props;\n    const shapeIndex = shapes.length;\n\n    this.updateState({\n      shapes: [\n        ...shapes,\n        {\n          ...newShape,\n          index: shapeIndex\n        }\n      ],\n      ...otherStates\n    });\n\n    return shapeIndex;\n  }\n\n  targettedShape = (index = undefined) => index || index === 0 ? this.props.shapes[index] : this.props.selectedShape;\n\n  onSelect = (event) => {\n    const { shapes, activeTab } = this.props;\n    if (!this._allowedTabs.includes(activeTab)) {\n      return;\n    }\n\n    const { offsetX, offsetY } = event;\n\n    \n    let foundShape = false;\n\n    shapes.forEach(\n      (shape) => {\n        if (\n            !shape.hidden\n            && offsetX >= shape.x\n            && offsetX <= shape.x + shape.width\n            && offsetY >= shape.y\n            && offsetY <= shape.y + shape.height\n            && shape.tab === activeTab\n          ) {\n            foundShape = true;\n\n            this.updateState({\n              selectedShape: {\n                ...shape,\n                resizingBox: true,\n                startEdgeOffset: {\n                  x: offsetX - shape.x,\n                  y: offsetY - shape.y,\n                }\n              }\n            });\n\n            this.activateResizingActions();\n            this._canvas.addEventListener('keyup', this.activateShapeDeleting);\n            this._canvas.addEventListener('mousemove', this.startDragging);\n            this._canvas.addEventListener('touchmove', this.startDragging);\n            document.addEventListener('mouseup', this.endDragging);\n            document.addEventListener('touchend', this.endDragging);\n          }\n      }\n    );\n\n    // Remove the old event listeners incase clicked on no shapes after clicking on one before.\n    if (!foundShape) {\n      this.updateState({ selectedShape: {} });\n      this.disableResizingActions();\n      this._canvas.removeEventListener('keyup', this.activateShapeDeleting);\n      this._canvas.removeEventListener('mousemove', this.startDragging);\n      this._canvas.removeEventListener('touchmove', this.startDragging);\n      document.removeEventListener('mouseup', this.endDragging);\n      document.removeEventListener('touchend', this.endDragging);\n    }\n  }\n\n  activateShapeDeleting = ({ key }) => {\n    const { selectedShape } = this.props;\n\n    if (\n        (key === 'Delete' || key === 'Backspace')\n        && selectedShape\n    ) {\n      this.deleteShapeByKeyOrIndex({ index: selectedShape.index });\n      this.updateState({ selectedShape: {} });\n      this.disableResizingActions();\n      this._canvas.removeEventListener('keyup', this.activateShapeDeleting);\n    }\n  }\n\n  activateResizingActions = () => {\n    const { selectedShape } = this.props;\n\n    if (selectedShape.lockScaleToPercentage) { return; }\n    \n    Array.from(document.getElementsByClassName('shape-resizing-control'))\n      .forEach((control) => {\n        control.addEventListener('mousedown', this.trackShapeResize)\n      });\n  }\n\n  trackShapeResize = ({ target }) => {\n    this.setState({ resizeControlTarget: target });\n    document.addEventListener('mousemove', this.handleShapeResizing);\n    document.addEventListener('touchmove', this.handleShapeResizing);\n    document.addEventListener('mouseup', this.disableResizingActions);\n    document.addEventListener('touchend', this.disableResizingActions);\n  }\n\n  handleShapeResizing = ({ movementX, movementY, shiftKey }) => {\n    const { resizeControlTarget } = this.state;\n    const { selectedShape, processWithCloudimage } = this.props;\n    let { index, width, height, x, y, variant, originalWidth, originalHeight } = selectedShape;\n\n    if (\n      !resizeControlTarget ||\n      (variant === SHAPES_VARIANTS.TEXT)\n    ) { return; }\n\n    const oldHeight = height;\n    \n    const { direction } = resizeControlTarget.dataset;\n    if (processWithCloudimage) {\n      const notAllowedWithCloudImage = ['e', 'w', 'n', 's'];\n      if (notAllowedWithCloudImage.includes(direction)) {\n        return;\n      }\n      shiftKey = true;\n    }\n    const keepShapeRatio = (sameAxesIncSign) => {\n      const ratio = width / height;\n      if (Math.abs(movementX) >= Math.abs(movementY)) {\n        const tempHeight = Math.abs(height - (width + movementX) / ratio);\n        movementY = (!sameAxesIncSign ? -1 : 1) * Math.sign(movementX) * tempHeight;\n      } else {\n        const tempWidth = Math.abs(width - ((height + movementY) * ratio));\n        movementX = (!sameAxesIncSign ? -1 : 1) * Math.sign(movementY) * tempWidth;\n      }\n    }\n    const eastHandle = () => { width += movementX; }\n    const southHandle = () => { height += movementY; }\n    const westHandle = () => {\n      width -= movementX;\n      x += movementX;\n    }\n    const northHandle = () => {\n      height -= movementY;\n      y += movementY;\n    }\n\n    switch(direction) {\n      case 'e':\n        eastHandle();\n      break;\n      case 'w':\n        westHandle();\n      break;\n      case 'n':\n        northHandle();\n      break;\n      case 's':\n        southHandle();\n      break;\n      case 'ne':\n        if (shiftKey) { keepShapeRatio(false); }\n        eastHandle();\n        if (width >= this._canvas.width && shiftKey) { break; }\n        northHandle();\n      break;\n      case 'nw':\n        if (shiftKey) { keepShapeRatio(true); }\n        westHandle();\n        if (width >= this._canvas.width && shiftKey) { break; }\n        northHandle();\n      break;\n      case 'se':\n        if (shiftKey) { keepShapeRatio(true); }\n        eastHandle();\n        if (width >= this._canvas.width && shiftKey) { break; }\n        southHandle();\n      break;\n      case 'sw':\n        if (shiftKey) { keepShapeRatio(false); }\n        westHandle();\n        if (width >= this._canvas.width && shiftKey) { break; }\n        southHandle();\n      break;\n      default:\n      return;\n    }\n\n    if (variant === SHAPES_VARIANTS.SQUARE || variant === SHAPES_VARIANTS.CIRCLE) {\n      if (height !== oldHeight) { width = height;} else { height = width; }\n    }\n\n    // In cloudimage process f max width or height don't increase any of them.\n    if (processWithCloudimage && (width >= originalWidth || height >= originalHeight)) {\n      return;\n    }\n\n    const minWidthAndHeight = 15;\n    if (\n        height <= minWidthAndHeight ||\n        width <= minWidthAndHeight\n      ) { return; }\n\n    // Limiting the dragging to be inside the canvas only.\n    if (x < 0) { x = 0 }\n    if (y < 0) { y = 0 }\n    if (x + width > this._canvas.width) { x = this._canvas.width - width }\n    if (y + height > this._canvas.height) { y = this._canvas.height - height }\n    if (width > this._canvas.width) { width = this._canvas.width }\n    if (height > this._canvas.height) { height = this._canvas.height }\n\n    const updatedShape = { width, height, x, y };\n\n    this.updateShape(updatedShape, index, {\n      selectedShape: {\n        ...selectedShape,\n        ...updatedShape\n      }\n    });\n  }\n\n  disableResizingActions = (e) => {\n    document.removeEventListener('mousemove', this.handleShapeResizing);\n    document.removeEventListener('mouseup', this.disableResizingActions);\n\n    this.updateState({ selectedShape: {} })\n    this.setState({ resizeControlTarget: null });\n  }\n\n  removeResizingBox = ({ offsetX, offsetY }) => {\n    const { selectedShape } = this.props;\n    if (\n        offsetX < selectedShape.x\n        || offsetX > selectedShape.x + selectedShape.width\n        || offsetY < selectedShape.y\n        || offsetY > selectedShape.y + selectedShape.height\n    ) {\n      this.updateState({\n        selectedShape: { ...selectedShape, resizingBox: false }\n      });\n\n      this._canvas.removeEventListener('click', this.removeResizingBox);\n    }\n  }\n\n  startDragging = (event) => {\n    if (event.targetTouches && event.targetTouches[0]) {\n      event.preventDefault();\n      const { clientX, clientY } = event.targetTouches[0];\n      const { x, y } = this._canvas.getBoundingClientRect();\n      event.offsetX = clientX - x;\n      event.offsetY = clientY - y;\n    }\n    \n    const { selectedShape } = this.props;\n    const { startEdgeOffset = {}, width, height, index } = selectedShape;\n    \n    // event.offsetX - startEdgeOffset.x for the shape's X from its starting point not the exact mouse position.\n    let newX = event.offsetX - startEdgeOffset.x;\n    let newY = event.offsetY - startEdgeOffset.y;\n\n    // Limiting the dragging to be inside the canvas only.\n    if (newX < 0) { newX = 0 }\n    if (newY < 0) { newY = 0 }\n    if (newX + width > this._canvas.width) { newX = this._canvas.width - width }\n    if (newY + height > this._canvas.height) { newY = this._canvas.height - height }\n\n    const newSelectedShape = {\n      ...selectedShape,\n      x: newX,\n      y: newY\n    }\n    \n    this.updateShape(newSelectedShape, index, { selectedShape: newSelectedShape });\n  }\n\n  endDragging = () => {\n    this._canvas.removeEventListener('mousemove', this.startDragging);\n    this._canvas.removeEventListener('mouseup', this.endDragging);\n    this._canvas.removeEventListener('mouseleave', this.endDragging);\n    this._canvas.addEventListener('click', this.removeResizingBox);\n  }\n\n  getCanvasCenter = (reduceWidthBy = 0, reduceHeightBy = 0) => {\n    const centeredX = (this._canvas.width / 2) - reduceWidthBy;\n    const centeredY = (this._canvas.height / 2) - reduceHeightBy;\n\n    return [centeredX, centeredY];\n  }\n\n  // All the repeated operations are passed here around the draw function.\n  draw = (drawFn, { opacity = 1.0, hidden, color, stroke = {} }) => {\n    if (hidden) { return; }\n\n    this._context.globalAlpha = +opacity;\n    this._context.fillStyle = color;\n    this._context.strokeStyle = stroke.color || 'transparent';\n    this._context.lineWidth = stroke.width || 1;\n    drawFn();\n    \n    // Make the new canvas rounded if the crop is rounded style.\n    // round is a manually written protoype method from canvas-round file in utils.\n    if (this.props.round) { this._context.round() }\n  }\n\n  redrawShape = (index = undefined) => {\n    let { shapes } = this.props;\n    \n    this.clearShape(0, 0, this._canvas.width, this._canvas.height);\n\n    const shapesCount = shapes.length;\n\n    // If the shape isn't the top shape (last in array) then re-order all the shapes and make the current as last one.\n    // Then re-draw with the new order otherwise re-draw with the old order which has the current shape as last/top one.\n    if (index && index !== shapesCount - 1) {\n      const currentShape = { ...shapes.splice(index, 1)[0], index: shapesCount };\n      shapes.splice(shapesCount, 0, currentShape);\n\n      shapes = shapes.map((shape, currentIndex) => {\n        shape.index = currentIndex;\n        this.drawShapeThroughVariant(shape);\n\n        return shape;\n      });\n\n      this.updateState({ shapes, selectedShape: currentShape });\n    } else {\n      shapes.forEach((shape) => this.drawShapeThroughVariant(shape));\n    }\n  }\n\n  drawShapeThroughVariant = (shape) => {\n    switch(shape.variant) {\n      case SHAPES_VARIANTS.IMAGE:\n        this.drawImage(shape);\n        break;\n      case SHAPES_VARIANTS.RECT:\n      case SHAPES_VARIANTS.SQUARE:\n        this.drawRect(shape);\n        break;\n      case SHAPES_VARIANTS.CIRCLE:\n        this.drawCircle(shape);\n        break;\n      case SHAPES_VARIANTS.TEXT:\n        this.drawText(shape);\n      default:\n        return;\n    }\n  }\n\n  drawRect = ({ x, y, width, height, stroke, ...others }) => {\n    this.draw(() => {\n      this._context.fillRect(x, y, width, height);\n      if (stroke) {\n        this._context.strokeRect(x, y, width, height);\n      }\n    }, { stroke, ...others });\n  }\n\n  drawCircle = ({ x, y, radius, width, height, stroke, ...others }) => {\n    this.draw(() => {\n      this._context.roundRect(x, y, width, height);\n      this._context.fill();\n\n      if (stroke) {\n        this._context.stroke();\n      }\n    }, { stroke, ...others });\n  }\n\n  drawImage = ({ img, x, y, width, height, stroke, ...others }) => {\n    this.draw(() => {\n      this._context.drawImage(img, x, y, width, height);\n      if (stroke) {\n        this._context.strokeRect(x, y, width, height);\n      }\n    }, { stroke, ...others });\n  }\n\n  setTextStyle = ({ textSize, textFont }) => {\n    this._context.textAlign = \"start\";\n    this._context.textBaseline = \"top\";\n    this._context.font = `${textSize}px ${textFont}`;\n  }\n\n  getTextWidthAndHeight = ({ text, textSize, textFont }) => {\n    this.setTextStyle({ textSize, textFont });\n    const metrics = this._context.measureText(text);\n    let { width } = metrics;\n    let height = width === 0 ? 0 : metrics.actualBoundingBoxDescent - metrics.actualBoundingBoxAscent;\n\n    return [width, height];\n  }\n\n  drawText = ({ text, textSize, textFont, x, y, stroke, ...others })  => {\n    this.draw(() => {\n      this.setTextStyle({ textSize, textFont });\n      this._context.fillText(text, x, y, this._canvas.width);\n      if (stroke) {\n        this._context.strokeText(text, x, y);\n      }\n    }, { stroke, ...others })\n  }\n\n  // TODO: add other shapes variants...\n\n  addRect = ({ x, y, width = 100, height = 75, stroke = {}, color = '#000000',\n    opacity = 1.0, variant = SHAPES_VARIANTS.RECT, tab = 'shapes', ...others } = {}\n  ) => {\n    const [centerX, centerY] = this.getCanvasCenter(width / 2, height / 2);\n\n    const drawingArgs = { x: x || centerX, y: y || centerY, width, height, stroke, opacity, color };\n    const allArgs = { ...this._initArgs, ...others, ...drawingArgs, variant, tab };\n\n    if (others.key && this.replaceShapeIfExisted(others.key, allArgs)) { return; }\n\n    this.drawRect(drawingArgs);\n    \n    const index = this.pushShapeToShapes(allArgs);\n\n    this.updateState({\n      selectedShape: { ...allArgs, index, resizingBox: true }\n    }, this.activateResizingActions);\n  }\n\n  addSquare = (rectArgs) => {\n    if (!rectArgs.width)\n      rectArgs.width = rectArgs.height = 75;\n    rectArgs.variant = SHAPES_VARIANTS.SQUARE;\n    this.addRect(rectArgs);\n  }\n\n  addCircle = ({ x, y, radius = 50, stroke = {}, color = '#000000',\n    opacity = 1.0, tab = 'shapes', ...others } = {}\n  ) => {\n    const [centerX, centerY] = this.getCanvasCenter(radius, radius);\n    const widthAndHeight = radius * 2;\n    \n    const drawingArgs = { x: x || centerX, y: y || centerY, radius, color, opacity, stroke,\n      width: widthAndHeight, height: widthAndHeight };\n    const allArgs = { ...this._initArgs, ...others, ...drawingArgs, tab, variant: SHAPES_VARIANTS.CIRCLE };\n\n    if (others.key && this.replaceShapeIfExisted(others.key, allArgs)) { return; }\n\n    this.drawCircle(drawingArgs);\n\n    const index = this.pushShapeToShapes(allArgs);\n\n    this.updateState({\n      selectedShape: { ...allArgs, index, resizingBox: true }\n    }, this.activateResizingActions);\n  }\n\n  addImage = (\n    { img, x = undefined, y = undefined, opacity = 1.0, tab='image', stroke = {}, otherStates, ...others } = {}\n  ) => {\n    if(img) {\n      const addIt = () => {        \n        const [originalWidth, originalHeight] = this.getSuitableImgDiemensions(img, others.lockScaleToPercentage);\n\n        const [centerX, centerY] = this.getCanvasCenter(\n          (others.width || originalWidth) / 2,\n          (others.height || originalHeight) / 2\n        );\n\n        const drawingArgs = {\n          img, opacity, originalWidth, originalHeight,\n          width: others.width || originalWidth,\n          height: others.height || originalHeight,\n          x: x || centerX,\n          y: y || centerY,\n          stroke\n        };\n\n        const allArgs = { ...this._initArgs, ...others, ...drawingArgs, variant: SHAPES_VARIANTS.IMAGE, tab };\n\n        if (others.key && this.replaceShapeIfExisted(others.key, allArgs, otherStates)) { return; }\n\n        this.drawImage(drawingArgs);\n\n        const index = this.pushShapeToShapes(allArgs);\n\n        this.updateState({\n          selectedShape: { ...allArgs, index, resizingBox: true },\n          ...otherStates\n        }, this.activateResizingActions);\n      }\n\n      if (typeof img === 'string') {\n        img = this.makeImgElement(img, addIt);\n      } else { addIt(); }\n      \n    }\n  }\n\n  addText = ({\n    text = 'Text', textSize = 62, color = \"#000000\", textFont = 'Arial', x = undefined, y = undefined,\n    stroke = {}, opacity = 1.0, tab = 'text', otherStates, ...others\n  } = {}) => {\n    const [width, height] = this.getTextWidthAndHeight({ text, textSize, textFont });\n    \n    // Set text style here for measuring the text's width & hegiht before drawing.\n    const [centerX, centerY] = this.getCanvasCenter(width / 2, height / 2);\n\n    if (text) {\n      const drawingArgs = { text, textSize, textFont, x: x || centerX, y: y || centerY, opacity,\n        stroke, color };\n      const allArgs = { ...this._initArgs, ...others, ...drawingArgs, width, height, variant: SHAPES_VARIANTS.TEXT, tab };\n\n      if (others.key && this.replaceShapeIfExisted(others.key, allArgs, otherStates)) { return; }\n\n      this.drawText(drawingArgs);\n\n      const index = this.pushShapeToShapes(allArgs);\n\n      this.updateState({\n        selectedShape: { ...allArgs, index, resizingBox: true },\n        ...otherStates\n      }, this.activateResizingActions);\n    }\n  }\n\n  addAnyShape = (shapeArgs, otherStates) => {\n    if (shapeArgs.index || shapeArgs.index === 0) {\n      const { shapes } = this.props;\n      const shape = shapes[shapeArgs.index];\n      if (!shapeArgs.variant || shape.variant === shapeArgs.variant) {\n        this.updateShape(shapeArgs, shapeArgs.index, otherStates);\n        return;\n      }\n    }\n\n    const args = { ...shapeArgs, otherStates };\n    switch(shapeArgs.variant) {\n      case SHAPES_VARIANTS.IMAGE:\n        this.addImage(args);\n        break;\n      case SHAPES_VARIANTS.RECT:\n        this.addRect(args);\n        break;\n      case SHAPES_VARIANTS.SQUARE:\n        this.addSquare(args);\n        break;\n      case SHAPES_VARIANTS.CIRCLE:\n        this.addCircle(args);\n        break;\n      case SHAPES_VARIANTS.TEXT:\n        this.addText(args);\n      default:\n        return;\n    }\n  }\n\n  getSuitableImgDiemensions = (img, lockScaleToPercentage = 0) => {\n    let width = img.width;\n    let height = img.height;\n\n    // Scaling down the image if it's bigger than the canvas\n    if (height > this._canvas.height) {\n      const ratio = height / this._canvas.height;\n      height /= ratio;\n      width /= ratio;\n    }\n\n    if (width > this._canvas.width) {\n      const ratio = width / this._canvas.width;\n      height /= ratio;\n      width /= ratio;\n    }\n\n    if (lockScaleToPercentage) {\n      const scaleValue = (lockScaleToPercentage / 100);\n      width *= scaleValue;\n      height *= scaleValue;\n    }\n    \n    width = this.fromLatestCanvasSizeValue(width, 'width');\n    height = this.fromLatestCanvasSizeValue(height, 'height');\n\n    return [width, height];\n  }\n\n  getShapeByKeyOrIndex = ({ key: shapeKey, index: shapeIndex }) => {\n    if (!shapeKey && !shapeIndex && shapeKey !== 0 && shapeIndex !== 0) { return false; }\n    const { shapes } = this.props;\n\n    return shapeIndex ? shapes[shapeIndex] : shapes.filter(({ key }) => key === shapeKey)[0];\n  }\n\n  replaceShapeIfExisted = (key, args, otherStates = undefined) => {\n    const shape = this.getShapeByKeyOrIndex({ key });\n\n    if (shape) {\n      args = { ...args, x: shape.x, y: shape.y, width: shape.width, height: shape.height };\n      this.updateShape(args, shape.index, otherStates)\n\n      return true;\n    }\n\n    return false;\n  }\n\n  setShapeVisibilityByKeyOrIndex = ({ key, index }, isHidden = undefined) => {\n    const shape = this.getShapeByKeyOrIndex({ key, index });\n    if (shape && shape.hidden !== isHidden) {\n      this.updateShape({ hidden: isHidden || !shape.hidden}, shape.index);\n    }\n  }\n\n  getShapesIndexByAnyProp = (propertyName, propertyValue) => {\n    const { shapes } = this.props;\n    \n    if (shapes && shapes.length === 0) { return []; }\n\n    const shapesIndicies = [];\n\n    shapes\n      .filter(({ [propertyName]: filterProp }, index) => {\n        if (filterProp === propertyValue ||\n            (typeof filterProp === 'undefined' && Boolean(filterProp) === propertyValue)\n         ) {\n          shapesIndicies.push(index);\n          return true;\n        }\n\n        return false;\n      });\n\n    return shapesIndicies;\n  }\n\n  updateShapes = (updatedData, otherStates, callback = () => {}) => {\n    let { shapes } = this.props;\n    shapes = shapes.map(s => ({ ...s, ...updatedData }));\n    this.updateState({ shapes, ...otherStates }, callback);\n  }\n\n  replaceAllShapes = (newShapes, callback = () => {}) => {\n    this.updateState({ shapes: newShapes }, () => {\n      this.redrawShape();\n      callback();\n    });\n  }\n\n  updateShape = (updatedData, index, otherStatesToBeUpdated = undefined) => {\n    const { shapes, selectedShape } = this.props;\n\n    if (!updatedData ||\n        (\n          (!index && index !== 0) &&\n          (!selectedShape || (!selectedShape.index && selectedShape.index !== 0))\n        ) \n      ) { return; }\n    \n    if (typeof updatedData.img === 'string') {\n      this.updateState({\n        selectedShape: { ...selectedShape, lockScaleToPercentage: updatedData.lockScaleToPercentage, img: updatedData.img }\n      });\n      this.makeImgElement(updatedData.img, this.updateShape, updatedData, index, otherStatesToBeUpdated);\n      return;\n    }\n\n    const updates = {};\n\n    // if no index provided and selected shape would be updated then add the obj and update the stats' selectes shape.\n    if (!index && index !== 0) { updates.selectedShape = { ...selectedShape, ...updatedData } }\n\n    index = index || index === 0 ? index : selectedShape.index;\n\n    if (shapes[index]) {\n      const latestShapes = shapes;\n\n      if (\n        (updatedData.textSize && updatedData.textSize !== shapes[index].textSize)||\n        (updatedData.text && updatedData.text !== shapes[index].text)\n      ) {\n        const targetShape = shapes[index];\n        const [width, height] = this.getTextWidthAndHeight({ ...targetShape, ...updatedData });\n\n        if (!updates.selectedShape) {\n          updatedData.width = width;\n          updatedData.height = height;\n          updatedData.text = updatedData.text || targetShape.text;\n        } else {\n          updatedData.width = updates.selectedShape.width = width;\n          updatedData.height = updates.selectedShape.height = height;\n          updatedData.text = updates.selectedShape.text = updatedData.text || targetShape.text;\n        }\n      } else {\n        const newData = { ...updatedData }\n\n        if (typeof updatedData.x !== 'undefined' && typeof updatedData.y !== 'undefined') {\n          newData.x = updatedData.x;\n          newData.y = updatedData.y; \n        }\n\n        if (updatedData.stroke) {\n          newData.stroke = updatedData.stroke;\n        }\n\n        if (updatedData.width && updatedData.height) {\n          newData.width = updatedData.width;\n          newData.height = updatedData.height;\n        }\n\n        if (updatedData.lockScaleToPercentage) {\n          updatedData.lockScaleToPercentage = updatedData.lockScaleToPercentage;\n        }\n\n        updates.selectedShape = {\n          ...selectedShape,\n          ...newData\n        }\n      }\n\n      latestShapes[index] = { ...latestShapes[index], ...updatedData };\n      this.updateState({ shapes: latestShapes, ...updates, ...otherStatesToBeUpdated }, () => {\n        this.redrawShape(index);\n      });\n    }\n  }\n\n  clearShape = (x, y, width, height, stroke = {}) => {\n    const { width: strokeWidth } = stroke;\n    const strokeWidthConst = strokeWidth || 1;\n\n    const clearFromX  = x - strokeWidthConst;\n    const clearFromY  =  y - strokeWidthConst;\n    const clearWidth  = width + strokeWidthConst;\n    const clearHeight = height + strokeWidthConst;\n\n    this._context.clearRect(clearFromX, clearFromY, clearWidth, clearHeight);\n  }\n  \n  eraseAndRemoveShapeFromArray = (index, shapes) => {\n    if (Object.keys(this.targettedShape(index)).length === 0) { return; }\n\n    this.clearShape(0, 0, this._canvas.width, this._canvas.height);\n    \n    const newShapes = shapes.filter(shape => {\n      if (shape.index === index) { return false; }\n      if (shape.index > index) { shape.index -= 1; };\n\n      this.drawShapeThroughVariant(shape);\n      return shape;\n    });\n\n    return newShapes;\n  }\n\n  deleteShapeByKeyOrIndex = ({ index, key }, otherStates = {}) => {\n    const { selectedShape } = this.props;\n\n    if (!index && index !== 0 && !key) {\n\n      if (!selectedShape) { return; }\n      \n      index = selectedShape.index;\n    }\n\n    const { shapes } = this.props;\n    const shapeIndex = index || index === 0 ? index : (this.getShapeByKeyOrIndex({ key }) || {}).index;\n\n    if (shapeIndex || shapeIndex === 0) {\n      if (shapeIndex === selectedShape.index) { otherStates.selectedShape = {} }\n      this.updateState({\n        shapes: this.eraseAndRemoveShapeFromArray(shapeIndex, shapes),\n        ...otherStates\n      });\n    }\n  }\n\n  deleteShapes = (indicies = [], otherStates) => {\n    let { shapes } = this.props;\n    indicies.forEach(i => {\n      shapes = this.eraseAndRemoveShapeFromArray(i, shapes)\n    });\n\n    this.updateState({\n      shapes,\n      ...otherStates\n    });\n  }\n\n  deleteAllShapesOrByTypeOrIndicies = ({ type, all = false, applied = false, secured = [] }) => {\n    if (!type && !all) { return; }\n\n    if (all) {\n      const watermarkIndex = (this.getShapeByKeyOrIndex({ key: WATERMARK_UNIQUE_KEY }) || {}).index;\n      const securedIndicies = [...secured];\n      if ((watermarkIndex || watermarkIndex === 0) && !securedIndicies.includes(watermarkIndex)) {\n        securedIndicies.push(watermarkIndex);\n      }\n\n      let shapes = [];\n      this.clearShape(0, 0, this._canvas.width, this._canvas.height);\n      if (!applied) {\n        shapes = this.props.shapes.filter(s => {\n          if (s.applied || securedIndicies.includes(s.index)) {\n            this.drawShapeThroughVariant(s);\n            return s;\n          }\n\n          return false;\n        });\n      }\n      this.updateState({ shapes, selectedShape: {} });\n      return;\n    }\n\n    const shapesIndicies = this.getShapesIndexByAnyProp('type', type);\n    if (shapesIndicies.length > 0) { this.deleteShapes(shapesIndicies); }\n  }\n\n  makeImgElement = (src, fn, dataObject, ...args) => {\n    if (!src) { return ''; }\n    this.updateState({ isShowSpinner: true });\n\n    const img = new Image();\n\n    img.crossOrigin = 'Anonymous';\n    img.src = `${src}?v=${Math.random()}`;\n\n    img.onload = () =>  {\n      if (dataObject) {\n        let width, height;\n        \n        if (dataObject.position) {\n          let x, y;\n          [\n            x,\n            y,\n            width,\n            height\n          ] = getWatermarkSquaredPosition(dataObject.position, this._canvas, img.width, img.height);\n\n          dataObject.x = x;\n          dataObject.y = y;\n        }\n\n        const [originalWidth, originalHeight] = this.getSuitableImgDiemensions(img, dataObject.lockScaleToPercentage);\n\n        dataObject.width = width || originalWidth;\n        dataObject.originalWidth = originalWidth;\n        dataObject.height =  height || originalHeight;\n        dataObject.originalHeight = originalHeight;\n\n        fn(dataObject,...args);\n      } else {\n        fn(...args);\n      }\n      \n      this.updateState({ isShowSpinner: false });\n    }\n\n    img.onerror = () => {\n      this.updateState({ isShowSpinner: false });\n      console.error('Error loading the image...');\n    }\n\n    if (dataObject){ dataObject.img = img }\n    return img;\n  }\n\n  fromLatestCanvasSizeValue = (number, property) => {\n    if (this._canvas && this.state.latestCanvasSize) {\n      // property = width or height\n      return number.mapNumber(0, this.state.latestCanvasSize[property], 0, this._canvas[property]);\n    }\n    \n    return number;\n  }\n\n\n  render() {\n    const {\n      height: parentCanvasHeight,\n      width: parentCanvasWidth,\n      selectedShape: {\n        width = 0,\n        height = 0,\n        x = 0,\n        y = 0,\n        resizingBox = false,\n        lockScaleToPercentage = 0\n      },\n      processWithCloudimage,\n      wrapperId\n    } = this.props\n    const resizingBoxLines = ['e', 'n', 'w', 's'];\n    const resizingBoxPoints = ['ne', 'nw', 'sw', 'se'];\n    if (!processWithCloudimage) {\n      resizingBoxPoints.splice(0, 0, 'e', 'n', 'w', 's',)\n    }\n    const left = (this._canvas ? this._canvas.offsetLeft : 0) + x;\n    const top = (this._canvas ? this._canvas.offsetTop : 0 ) + y;\n    const mutualStyles = { pointerEvents: 'all' };\n\n    return (\n      <>\n        <PreviewCanvas\n          ref={this.canvasRef}\n          id={`${wrapperId}_${PREVIEW_CANVAS_ID}`}\n          width={parentCanvasWidth}\n          height={parentCanvasHeight}\n          tabIndex={1}\n        />\n\n        <div\n          ref={this.shapeResizingBoxRef}\n          className=\"cropper-crop-box\"\n          style={{ display: resizingBox && !lockScaleToPercentage ? 'block' : 'none',\n            width, height, left, top, pointerEvents: 'none' }}\n        >\n          {resizingBoxLines.map((l) => (\n            <span\n              key={l}\n              className={`cropper-line line-${l} shape-resizing-control`}\n              data-direction={l}\n              style={mutualStyles}\n            ></span>\n            )\n          )}\n          {resizingBoxPoints.map((p) => (\n            <span\n              key={p}\n              className={`cropper-point point-${p} shape-resizing-control`}\n              data-direction={p}\n              style={mutualStyles}\n            ></span>\n            )\n          )}\n        </div>\n      </>\n    );\n  }\n\n}\n","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Preview\\ImageManipulator.js",["559","560","561"],"import React, { Component } from 'react';\nimport { Canvas } from '../../styledComponents';\nimport {\n  b64toBlob,\n  deepCopy,\n  getBaseAPI,\n  getCanvasNode,\n  getEffectHandlerName,\n  getPubliclink,\n  getSecretHeaderName,\n  getImageSealingParams,\n  roundDecimalPoint\n} from '../../utils';\nimport {\n  CLOUDIMAGE_OPERATIONS,\n  ON_CLOSE_STATUSES,\n  PREVIEW_CANVAS_ID,\n  WATERMARK_UNIQUE_KEY,\n  CANVAS_ID,\n  ORIGINAL_CANVAS_ID,\n  SAVE_MODES\n} from '../../config';\nimport Cropper from 'cropperjs';\nimport uuidv4 from 'uuid/v4';\nimport '../../utils/canvas-round';\nimport '../../utils/map-number-range';\n\n\nconst INITIAL_PARAMS = {\n  effect: null,\n  filter: null,\n  crop: null,\n  resize: null,\n  rotate: null,\n  correctionDegree: 0,\n  flipX: false,\n  flipY: false,\n  adjust: {\n    brightness: 0,\n    contrast: 0,\n    saturation: 0,\n    exposure: 0\n  },\n  canvasDimensions: { width: 300, height: 200, ratio: 1.5 }\n};\n\n\nexport default class ImageManipulator extends Component {\n  constructor() {\n    super();\n\n    this.state = {\n      canvas: null,\n      self: this\n    };\n\n    this.CamanInstance = null;\n    this.CamanInstanceOriginal = null;\n    this.CamanInstanceZoomed = null;\n  }\n\n  shouldComponentUpdate() { return false; }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    const additionalState = {};\n    if (nextProps.activeTab !== prevState.activeTab) {\n      if (prevState.activeTab) prevState.self.destroyMode(prevState.activeTab);\n\n      if (nextProps.activeTab === 'watermark') {\n        additionalState.tempWatermark = nextProps.watermark && deepCopy(nextProps.watermark);\n      }\n      prevState.self.changeTab(nextProps.activeTab);\n    }\n\n    return { ...additionalState, ...nextProps };\n  }\n\n  componentDidMount() {\n    const that = this;\n    const { updateState, img, isPreResize, preCanvasDimensions } = this.props;\n\n    updateState({\n      isShowSpinner: true,\n      applyChanges: this.applyChanges,\n      applyOperations: this.applyOperations,\n      resetAll: this.resetAll,\n      onRotate: this.onRotate,\n      onAdjust: this.onAdjust,\n\n      downloadImage: this.downloadImage,\n      getResultCanvas: this.getResultCanvas,\n      saveImage: this.saveImage,\n\n      applyCorrections: this.applyCorrections,\n      restoreAll: this.restoreAll,\n      cancelLastOperation: this.cancelLastOperation\n    }, () => {\n      const canvas = this.getCanvas();\n      const ctx = canvas.getContext('2d');\n\n      canvas.width = img.width;\n      canvas.height = img.height;\n\n      ctx.drawImage(img, 0, 0, img.width, img.height);\n\n      const original = { height: img.height, width: img.width, ratio: img.width / img.height }\n\n      updateState({ original, canvasDimensions: original });\n\n      if (isPreResize && preCanvasDimensions) {\n        new window.Caman(canvas, function () {\n\n          this.resize({ width: preCanvasDimensions.width, height: preCanvasDimensions.height });\n\n          this.render(() => {\n            const resizedCanvas = that.replaceWithNewCanvas(CANVAS_ID);\n            const original = {\n              height: resizedCanvas.height,\n              width: resizedCanvas.width,\n              ratio: resizedCanvas.width / resizedCanvas.height\n            };\n\n            updateState({\n              original,\n              canvasDimensions: { ...original },\n              canvasOriginal: that.cloneCanvas(resizedCanvas)\n            }, () => {\n              that.initializeCanvases(resizedCanvas);\n            });\n          });\n        });\n      } else {\n        this.initializeCanvases(img);\n      }\n    });\n  }\n\n  getCanvas = (id = null, originalCanvas = false) => {\n    const editorWrapperId = this.props.config.elementId;\n    return getCanvasNode(editorWrapperId, id, originalCanvas);\n  }\n\n  initializeCanvases = (elem) => {\n    const that = this;\n    const { config: { isLowQualityPreview } = {}, updateState } = this.props;\n    let initialZoom = 1;\n\n    if (isLowQualityPreview && elem.height > 1050) {\n      const canvasOriginal = this.getCanvas(null, true);\n      const ctxOriginal = canvasOriginal.getContext('2d');\n\n      canvasOriginal.width = elem.width;\n      canvasOriginal.height = elem.height;\n\n      ctxOriginal.drawImage(elem, 0, 0, elem.width, elem.height);\n\n      initialZoom = elem.height / 800;\n\n      const zoomedWidth = elem.width / initialZoom;\n      const zoomedHeight = elem.height / initialZoom;\n\n      updateState({ initialZoom, canvasOriginal: that.cloneCanvas(canvasOriginal) });\n\n      setTimeout(() => {\n        const getCanvas = this.getCanvas;\n        new window.Caman(getCanvas(), function () {\n          this.resize({ width: zoomedWidth, height: zoomedHeight });\n\n          this.render(() => {\n            const canvasZoomed = that.replaceWithNewCanvas(CANVAS_ID);\n\n            that.CamanInstanceZoomed = new window.Caman(\n              canvasZoomed,\n              function () {\n                that.CamanInstanceOriginal = new window.Caman(getCanvas(null, true), function () {});\n                updateState({ isShowSpinner: false, canvasZoomed: that.cloneCanvas(canvasZoomed) });\n              }\n            );\n          });\n        });\n      });\n    } else {\n      setTimeout(() => {\n        const getCanvas = this.getCanvas();\n        that.CamanInstance = new window.Caman(getCanvas, function () {\n          updateState({ isShowSpinner: false, canvasOriginal: that.cloneCanvas(getCanvas) });\n        });\n      });\n    }\n  }\n\n  mergeCanvases = (canvas) => {\n    const { shapeOperations } = this.props;\n    const tempCtx = canvas.getContext('2d');\n    const finalPreviewCanvas = shapeOperations.prepareFinalCanvas(canvas);\n\n    tempCtx.drawImage(finalPreviewCanvas, 0, 0);\n    return canvas.toDataURL();\n  }\n\n  cloneCanvas = (oldCanvas) => {\n    //create a new canvas\n    const newCanvas = document.createElement('canvas');\n    const context = newCanvas.getContext('2d');\n\n    //set dimensions\n    newCanvas.width = oldCanvas.width;\n    newCanvas.height = oldCanvas.height;\n\n    // set old id\n    newCanvas.id = oldCanvas.id;\n    newCanvas.className = oldCanvas.className;\n\n    //apply the old canvas to the new one\n    context.drawImage(oldCanvas, 0, 0);\n\n    //return the new canvas\n    return newCanvas;\n  }\n\n  replaceWithNewCanvas = (id, rounded = false) => {\n    //create a new canvas\n    const oldCanvas = this.getCanvas(id);\n    const { width, height } = oldCanvas;\n    let newCanvas = document.createElement('canvas');\n    let context = newCanvas.getContext('2d');\n    const container = oldCanvas.parentElement;\n    container.removeChild(oldCanvas)\n\n    //set dimensions\n    newCanvas.width = width;\n    newCanvas.height = height;\n    newCanvas.id = `${this.props.config.elementId}_${id}`;\n    newCanvas.className = oldCanvas.className;\n\n    //apply the old canvas to the new one\n    context.drawImage(oldCanvas, 0, 0);\n\n    // Make the new canvas rounded if the crop is rounded style.\n    // round is a manually written protoype method from canvas-round file in utils.\n    if (rounded) { context.round() }\n\n    // Append the new canvas to the container of old canvas.\n    container.appendChild(newCanvas);\n\n    //return the new canvas\n    return newCanvas;\n  }\n\n  replaceCanvas = (newCanvas, id) => {\n    //create a new canvas\n    const oldCanvas = this.getCanvas(id);\n    const container = oldCanvas.parentElement;\n    container.removeChild(oldCanvas)\n\n    container.appendChild(newCanvas);\n\n    //return the new canvas\n    return newCanvas;\n  }\n\n  saveImage = () => {\n    const {\n      onComplete, onClose, updateState, closeOnLoad, config, processWithCloudService, uploadCloudimageImage,\n      operations, initialZoom, operationsOriginal\n    } = this.props;\n    const imageMime = this.getFinalImageMime();\n    const imageNameFromUrl = this.getFinalImageName();\n    const { filerobot = {}, platform = 'filerobot' } = config;\n    const { imageMeta, imageProperties, imageName, saveMode = SAVE_MODES.DUPLICATE } = filerobot;\n    const src = this.props.src.split('?')[0];\n    const canvasID = initialZoom !== 1 ? ORIGINAL_CANVAS_ID : CANVAS_ID;\n    const canvas = this.getCanvas(canvasID);\n    const baseAPI = getBaseAPI(filerobot.baseAPI, filerobot.container, platform);\n    const uploadParams = filerobot.uploadParams || {};\n    const dir = uploadParams.dir || 'image-editor';\n    const self = this;\n\n    if (!processWithCloudService) {\n      this.mergeCanvases(canvas);\n\n      const base64 = canvas.toDataURL(imageMime);\n      const block = base64.split(\";\");\n      const realData = block[1].split(\",\")[1];\n      const blob = b64toBlob(realData, imageMime, null);\n      const loweredSaveModeStr = saveMode.toLowerCase();\n      let name = imageName || imageNameFromUrl;\n\n      if (loweredSaveModeStr !== SAVE_MODES.REPLACE) {\n        const splittedName = name.replace(/-version-.{6}/g, '').split('.');\n        const nameLength = splittedName.length;\n\n        if (nameLength <= 1) {\n          name = `${splittedName.join('.')}-version-${(uuidv4() || '').slice(0, 6)}`;\n        } else {\n          name = [\n            splittedName.slice(0, nameLength - 1).join('.'),\n            '-version-',\n            (uuidv4() || '').slice(0, 6),\n            '.',\n            splittedName[nameLength - 1]\n          ].join('');\n        }\n      }\n\n\n      const formData = new FormData();\n      const request = new XMLHttpRequest();\n\n      request.addEventListener(\"load\", self.onFileLoad);\n      formData.append('file', blob, name);\n      \n      if (loweredSaveModeStr !== SAVE_MODES.NEW) {\n        if (imageProperties && Object.keys(imageProperties).length > 0) {\n          formData.append('properties[file]', JSON.stringify(imageProperties));\n        }\n        if (imageMeta && Object.keys(imageMeta).length > 0) {\n          formData.append('meta[file]', JSON.stringify(imageMeta));\n        }\n      }\n      request.open(\"POST\", [baseAPI, `upload?dir=${dir}`].join(''));\n      request.setRequestHeader(getSecretHeaderName(platform), filerobot.uploadKey);\n      request.send(formData);\n    } else {\n      const resultOperations = initialZoom !== 1 ? operationsOriginal : operations;\n      const allowedOperations = resultOperations.filter(({ operation }) => CLOUDIMAGE_OPERATIONS.includes(operation));\n      const url = this.generateCloudimageURL(allowedOperations, src.replace(/https?:\\/\\/scaleflex.ultrafast.io\\//, ''));\n\n      if (uploadCloudimageImage) {\n        const request = new XMLHttpRequest();\n\n        request.addEventListener(\"load\", this.onFileLoad);\n        request.open(\"POST\", [baseAPI, `upload?dir=${dir}`].join(''));\n        request.setRequestHeader(getSecretHeaderName(platform), filerobot.uploadKey);\n        request.setRequestHeader('Content-Type', 'application/json');\n        request.send(JSON.stringify({ files_urls: [url] }));\n      } else {\n        updateState({ isShowSpinner: false, isHideCanvas: false });\n        onComplete(url, { url_permalink: url, url_public: url, url: { public: url, permalink: url } });\n        closeOnLoad && onClose(ON_CLOSE_STATUSES.IMAGE_UPLOADED_CLOUDIMAGE);\n      }\n    }\n  }\n\n  getResultCanvas = () => {\n    const { initialZoom } = this.props;\n    const canvasID = initialZoom !== 1 ? ORIGINAL_CANVAS_ID : CANVAS_ID;\n    const canvas = this.getCanvas(canvasID);\n\n    this.mergeCanvases(canvas);\n\n    return canvas;\n  }\n\n  getFinalImageMime = () => {\n    const { roundCrop, imageMime } = this.props;\n\n    return roundCrop ? 'image/png' : imageMime;\n  }\n\n  getFinalImageName = () => {\n    const { roundCrop } = this.props;\n    let { imageName } = this.state;\n\n    if (roundCrop) {\n      imageName = imageName.replace(imageName.substr(imageName.lastIndexOf('.') + 1), 'png');\n    }\n\n    return imageName;\n  }\n\n  downloadImage = (callback) => {\n    const canvas = this.getResultCanvas();\n    const imageName = this.getFinalImageName();\n    const imageMime = this.getFinalImageMime();\n    const lnk = document.createElement('a');\n    let e;\n\n    lnk.download = imageName;\n    lnk.href = canvas.toDataURL(imageMime, 0.8);\n\n    if (document.createEvent) {\n      e = document.createEvent(\"MouseEvents\");\n      e.initMouseEvent(\"click\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n      lnk.dispatchEvent(e);\n    } else if (lnk.fireEvent) {\n      lnk.fireEvent(\"onclick\");\n    }\n\n    if (callback) callback();\n  }\n\n  onFileLoad = (data) => {\n    const { onComplete, onClose, updateState, closeOnLoad } = this.props;\n    const { srcElement = {} } = data;\n    const { response = '{}' } = srcElement;\n    const responseData = JSON.parse(response) || {};\n\n    if (responseData.status === 'success') {\n      const { file = {} } = responseData;\n      const publicURL = getPubliclink(file);\n\n      if (!publicURL) return;\n\n      updateState({ isShowSpinner: false, isHideCanvas: false });\n      onComplete(publicURL, file);\n      closeOnLoad && onClose(ON_CLOSE_STATUSES.IMAGE_UPLOADED_FILEROBOT);\n    } else {\n      updateState({ isShowSpinner: false, isHideCanvas: false });\n      alert(responseData);\n      closeOnLoad && onClose(ON_CLOSE_STATUSES.IMAGE_UPLOADING_FAIL_FILEROBOT);\n    }\n  }\n\n  generateCloudimageURL = (operations, original) => {\n    const { config, watermark, logoImage, processWithCloudimage, processWithFilerobot, imageSealing } = this.props;\n    const { cloudimage = {}, filerobot = {} } = config;\n    const cloudUrl = processWithCloudimage && (cloudimage.token + '.cloudimg.io/' + (cloudimage.version ? `${cloudimage.version}/` : 'v7/'));\n    const filerobotURL = processWithFilerobot && (filerobot.token + '.filerobot.com/' + (filerobot.version ? `${filerobot.version}/` : ''));\n    const doNotPrefixURL = filerobotURL ? filerobot.doNotPrefixURL : cloudimage.doNotPrefixURL;\n    let url = filerobotURL || cloudUrl || '';\n    url = (url ? 'https://' : '') + url;\n    const baseURL = doNotPrefixURL ? '' : url;\n    const cropOperation = this.isOperationExist(operations, 'crop');\n    const resizeOperation = this.isOperationExist(operations, 'resize');\n    const orientationOperation = this.isOperationExist(operations, 'rotate');\n    const focusPointOperation = this.isOperationExist(operations, 'focus_point');\n    const watermarkOperation = watermark && logoImage && watermark.applyByDefault;\n    const isProcessImage = cropOperation || resizeOperation || orientationOperation || watermarkOperation || focusPointOperation;\n\n    let cropQuery = '';\n    let resizeQuery = '';\n    let orientationQuery = '';\n    let watermarkQuery = '';\n    let focusPointQuery = '';\n\n    if (cropOperation) {\n      cropQuery = this.getCropArguments(cropOperation.props);\n    }\n\n    if (resizeOperation) {\n      resizeQuery = (cropQuery ? '&' : '') + this.getResizeArguments(resizeOperation.props);\n    }\n\n    if (orientationOperation) {\n      orientationQuery = ((cropQuery || resizeQuery) ? '&' : '') +\n        this.getOrientationArguments(orientationOperation.props);\n    }\n\n    if (watermarkOperation) {\n      watermarkQuery = ((cropQuery || resizeQuery || orientationQuery) ? '&' : '') +\n        this.getWatermarkArguments();\n    }\n\n    if (focusPointOperation) {\n      focusPointQuery = ((cropQuery || resizeQuery || orientationQuery || watermarkQuery) ? '&' : '') +\n        this.getFocusPointArguments(focusPointOperation.props);\n    }\n\n    original = original.split('?')[0]; // remove quesry string from original url\n    original = original.replace(baseURL, ''); // remove duplication in case when original url already include cdn prefix\n\n    let paramsStr = cropQuery + resizeQuery + orientationQuery + watermarkQuery + focusPointQuery;\n\n    if (imageSealing.enabled) {\n      paramsStr = getImageSealingParams(\n          paramsStr,\n          imageSealing,\n          original.replace(url, '') // always remove cdn url, to support already cdnized links and doNotPrefixURL param\n      );\n    }\n\n    return baseURL + original + (paramsStr ? '?' : '') + paramsStr;\n  }\n\n  /* Filters and Effects */\n\n  initFiltersOrEffects = () => { }\n\n  applyFilterOrEffect = (type, callback = () => {}) => {\n    const { updateState, initialZoom } = this.props;\n\n    if (!this.props[type]) return;\n\n    updateState({ isHideCanvas: true, isShowSpinner: true }, () => {\n      if (initialZoom !== 1) {\n        this.CamanInstanceOriginal.revert(false);\n\n        this.CamanInstanceOriginal[getEffectHandlerName(this.props[type])]();\n\n        this.CamanInstanceOriginal.render(() => {\n          updateState({ [type]: null }, () => {\n            this.makeCanvasSnapshot({ operation: type }, callback);\n          });\n        });\n      } else {\n        updateState({ [type]: null }, () => {\n          this.makeCanvasSnapshot({ operation: type }, callback);\n        });\n      }\n    });\n  }\n\n  applyAdjust = (callback = () => {}) => {\n    const { updateState, initialZoom, adjust } = this.props;\n    const { brightness, contrast, saturation, exposure } = adjust;\n    const resetProps = { brightness: 0, contrast: 0, saturation: 0, exposure: 0 };\n\n    updateState({ isHideCanvas: true, isShowSpinner: true }, () => {\n      if (initialZoom !== 1) {\n        this.CamanInstanceOriginal.revert(false);\n\n        if (brightness.toString() !== '0') this.CamanInstanceOriginal.brightness(parseInt(brightness || '0'));\n        if (contrast.toString() !== '0') this.CamanInstanceOriginal.contrast(parseInt(contrast || '0'));\n        if (saturation.toString() !== '0') this.CamanInstanceOriginal.saturation(parseInt(saturation || '0'));\n        if (exposure.toString() !== '0') this.CamanInstanceOriginal.exposure(parseInt(exposure || '0'));\n\n        this.CamanInstanceOriginal.render(() => {\n          updateState({ adjust: { ...resetProps } }, () => {\n            this.makeCanvasSnapshot({ operation: 'adjust' }, callback);\n          });\n        });\n      } else {\n        updateState({ adjust: { ...resetProps } }, () => {\n          this.makeCanvasSnapshot({ operation: 'adjust' }, callback);\n        });\n      }\n    });\n  }\n\n  /* Rotate */\n\n  initOrientation = () => {\n    const { config, redoOperation, operations, operationsZoomed, initialZoom } = this.props;\n    const { processWithCloudService } = config;\n    const currentOperations = initialZoom !== 1 ? operationsZoomed : operations;\n\n    if (processWithCloudService && currentOperations.length >= 1) {\n      const prevCropIndex = currentOperations.findIndex(({ operation }) => operation === 'rotate');\n\n      if (prevCropIndex > -1) {\n        redoOperation({ operationIndex: prevCropIndex - 1, callback: () => {}, resetActiveTab: false });\n      }\n    }\n  }\n\n  onRotate = (value = 0, correctionDegree = 0, flipX = false, flipY = false) => {\n    const { initialZoom, rotate, updateState } = this.props;\n    const nextRotateValue = rotate + value;\n\n    updateState({\n      isHideCanvas: true,\n      isShowSpinner: true,\n      rotate: nextRotateValue,\n      correctionDegree,\n      flipX,\n      flipY\n    }, () => {\n      const oldCanvas = this.getCanvas();\n\n      if (initialZoom !== 1) {\n        this.CamanInstanceZoomed.reset();\n\n        if (flipX) this.CamanInstanceZoomed.flip('x');\n        if (flipY) this.CamanInstanceZoomed.flip('y');\n        if (nextRotateValue || correctionDegree) this.CamanInstanceZoomed.rotate((nextRotateValue || 0) + (correctionDegree || 0));\n\n        this.CamanInstanceZoomed.render(() => {\n          this.getCanvas().className = oldCanvas.className;\n          updateState({ isHideCanvas: false, isShowSpinner: false });\n        });\n      } else {\n        this.CamanInstance.reset();\n\n        if (flipX) this.CamanInstance.flip('x');\n        if (flipY) this.CamanInstance.flip('y');\n        if (nextRotateValue || correctionDegree) this.CamanInstance.rotate((nextRotateValue || 0) + (correctionDegree || 0));\n\n        this.CamanInstance.render(() => {\n          this.getCanvas().className = oldCanvas.className;\n          updateState({ isHideCanvas: false, isShowSpinner: false });\n        });\n      }\n    });\n  }\n\n  applyOrientation = (callback = () => {}) => {\n    const { updateState, initialZoom, rotate, correctionDegree, flipX, flipY } = this.props;\n\n    updateState({ isHideCanvas: true, isShowSpinner: true }, () => {\n      const oldCanvas = this.getCanvas(null, true);\n      let nextRotate = (rotate || 0) + (correctionDegree || 0);\n\n      if (initialZoom !== 1) {\n        this.CamanInstanceOriginal.reset();\n\n        if (flipX) this.CamanInstanceOriginal.flip('x');\n        if (flipY) this.CamanInstanceOriginal.flip('y');\n        if (rotate || correctionDegree) this.CamanInstanceOriginal.rotate(nextRotate);\n\n        this.CamanInstanceOriginal.render(() => {\n          this.getCanvas(null, true).className = oldCanvas.className;\n          updateState({ rotate: 0, flipX: false, flipY: false, correctionDegree: 0 }, () => {\n            this.makeCanvasSnapshot({ operation: 'rotate', props: { rotate: nextRotate } }, callback);\n          });\n        });\n      } else {\n          this.getCanvas(null, true).className = oldCanvas.className;\n          updateState({ rotate: 0, flipX: false, flipY: false, correctionDegree: 0 }, () => {\n          this.makeCanvasSnapshot({ operation: 'rotate', props: { rotate: nextRotate } }, callback);\n        });\n      }\n    });\n  }\n\n  getOrientationArguments = ({ rotate } = {}) => {\n    switch (rotate) {\n      case 90:\n        return `r=270`;\n      case -90:\n        return `r=90`;\n      default:\n        return `r=${rotate}`;\n    }\n  }\n\n  /* Crop */\n\n  initCrop = () => {\n    const { config, redoOperation, operations, operationsZoomed, initialZoom } = this.props;\n    const { processWithCloudService } = config;\n    const currentOperations = initialZoom !== 1 ? operationsZoomed : operations;\n\n    if (processWithCloudService && currentOperations.length >= 1) {\n      const prevCropIndex = currentOperations.findIndex(({ operation }) => operation === 'crop');\n\n      if (prevCropIndex > -1) {\n        redoOperation({ operationIndex: prevCropIndex - 1, callback: this.onInitCrop, resetActiveTab: false });\n      }\n    } else {\n      this.onInitCrop();\n    }\n  }\n\n  onInitCrop = () => {\n    const {\n      updateState, \n      config: {\n        beginCropArea = 1,\n        minCropAreaWidth,\n        minCropAreaHeight\n      }\n    } = this.props;\n\n    updateState(\n      { isHideCanvas: true, isShowSpinner: true },\n      () => {\n        const canvas = this.getCanvas();\n        const rect = canvas.getBoundingClientRect();\n        const zoom = canvas.width / rect.width;\n\n        this.cropper = new Cropper(canvas, {\n          viewMode: 1,\n          modal: false,\n          background: false,\n          rotatable: false,\n          scalable: false,\n          zoomable: false,\n          movable: false,\n          autoCropArea: beginCropArea,\n          minCropBoxWidth: minCropAreaWidth,\n          minCropBoxHeight: minCropAreaHeight,\n          crop: event => {\n            this.props.updateState({ cropDetails: event.detail });\n          }\n        });\n\n        window.scaleflexPlugins = window.scaleflexPlugins || {};\n        window.scaleflexPlugins.zoom = zoom;\n        window.scaleflexPlugins.cropperjs = this.cropper;\n\n        updateState({ isHideCanvas: false, isShowSpinner: false });\n      }\n    );\n  }\n\n  applyCrop = (callback = () => {}) => {\n    const { initialZoom, updateState, cropDetails, roundCrop } = this.props;\n    const { width, height, x, y } = cropDetails;\n\n    updateState({ isShowSpinner: true }, () => {\n      let resultSize;\n      this.destroyCrop();\n\n      if (initialZoom !== 1) {\n        resultSize = [width, height, x, y].map(prop => prop * initialZoom);\n        this.CamanInstanceZoomed.crop(width, height, x, y);\n        this.CamanInstanceOriginal.crop(...resultSize);\n      } else {\n        resultSize = [width, height, x, y];\n        this.CamanInstance.crop(...resultSize);\n      }\n\n      this.makeCanvasSnapshot({\n        operation: 'crop',\n        props: {\n          width: resultSize[0],\n          height: resultSize[1],\n          x: resultSize[2],\n          y: resultSize[3],\n          roundCrop,\n        }\n      }, callback);\n    });\n  }\n\n  makeCanvasSnapshot = (operation, callback = () => {}, previewCanvas = false) => {\n    const { updateState, initialZoom, operationsZoomed, currentOperation, operationsOriginal,\n      operations, roundCrop } = this.props;\n\n    const isZoomed = initialZoom !== 1;\n\n    if (previewCanvas) {\n      const lastOperationIndex = (isZoomed ? operationsZoomed : operations).indexOf(currentOperation) + 1;\n\n      const zoomedCanvas = this.cloneCanvas(this.getCanvas());\n      const nextOperation = {\n        ...operation,\n        previewCanvas: true,\n        canvas: zoomedCanvas\n      };\n\n      const stateObj = {\n        isHideCanvas: false,\n        isShowSpinner: false,\n        currentOperation: nextOperation\n      }\n\n      if (isZoomed) {\n        stateObj.operationsZoomed = [...operationsZoomed.slice(0, lastOperationIndex), nextOperation];\n        stateObj.operationsOriginal = [...operationsOriginal.slice(0, lastOperationIndex), {\n          ...nextOperation,\n          canvas: this.cloneCanvas(this.getCanvas(null, true))\n        }];\n        stateObj.isHideCanvasOriginal = false;\n        stateObj.isShowSpinnerOriginal = false;\n      } else {\n        stateObj.operations = [...operations.slice(0, lastOperationIndex), nextOperation]\n      }\n\n      updateState(stateObj, callback);\n      return;\n    }\n\n    if (isZoomed) {\n      const lastOperationIndex = operationsZoomed.indexOf(currentOperation) + 1;\n\n      this.CamanInstanceOriginal.render(() => {\n        const canvasOriginal = this.replaceWithNewCanvas(ORIGINAL_CANVAS_ID, roundCrop);\n        const nextOperation = {\n          ...operation,\n          canvas: this.cloneCanvas(this.getCanvas(null, true))\n        };\n\n        this.CamanInstanceOriginal = new window.Caman(canvasOriginal, () => {\n          updateState({\n            isHideCanvasOriginal: false,\n            isShowSpinnerOriginal: false,\n            operationsOriginal: [...operationsOriginal.slice(0, lastOperationIndex), nextOperation]\n          }, callback);\n        });\n      });\n\n      const getCanvas = this.getCanvas;\n\n      this.CamanInstanceZoomed.render(() => {\n        const canvasZoomed = this.replaceWithNewCanvas(CANVAS_ID, roundCrop);\n        const nextOperation = {\n          ...operation,\n          canvas: this.cloneCanvas(getCanvas())\n        };\n\n        this.CamanInstanceZoomed = new window.Caman(canvasZoomed, () => {\n          updateState({\n            isHideCanvas: false,\n            isShowSpinner: false,\n            operationsZoomed: [...operationsZoomed.slice(0, lastOperationIndex), nextOperation],\n            currentOperation: nextOperation\n          });\n        });\n      });\n    } else {\n      const lastOperationIndex = operations.indexOf(currentOperation) + 1;\n      const getCanvas = this.getCanvas;\n      \n      this.CamanInstance.render(() => {\n        const canvas = this.replaceWithNewCanvas(CANVAS_ID, roundCrop);\n        const nextOperation = {\n          ...operation,\n          canvas: this.cloneCanvas(getCanvas())\n        };\n\n        this.CamanInstance = new window.Caman(canvas, () => {\n          updateState({\n            isHideCanvas: false,\n            isShowSpinner: false,\n            operations: [...operations.slice(0, lastOperationIndex), nextOperation],\n            currentOperation: nextOperation\n          }, callback);\n        });\n      });\n    }\n  }\n\n  destroyCrop = () => {\n    this.cropper.destroy();\n  }\n\n  getCropArguments = ({ width, height, x, y, roundCrop } = {}) => `tl_px=${Math.round(x)},${Math.round(y)}&br_px=${Math.round(x + width)},${Math.round(y + height)}${roundCrop ? `&radius=${Math.round(Math.max(width, height))}&force_format=png` : ''}`;\n\n  /* Resize */\n\n  initResize = () => {\n    const { initialZoom, updateState } = this.props;\n    let canvas = this.getCanvas(\n      initialZoom !== 1 ? ORIGINAL_CANVAS_ID : CANVAS_ID\n    );\n    const nextCanvasDimensions = { width: canvas.width, height: canvas.height, ratio: canvas.width / canvas.height };\n\n    updateState({ canvasDimensions: nextCanvasDimensions });\n  }\n\n  applyResize = () => {\n    const { initialZoom, canvasDimensions, updateState, handleSave, operations, operationsOriginal } = this.props;\n\n    updateState({\n      isHideCanvas: true,\n      isShowSpinner: true,\n      operationsOriginal: [...operationsOriginal, { operation: 'resize', props: canvasDimensions }],\n      operations: [...operations, { operation: 'resize', props: canvasDimensions }]\n    }, () => {\n      if (initialZoom !== 1) {\n        this.CamanInstanceOriginal.resize(canvasDimensions);\n\n        this.CamanInstanceOriginal.render(() => {\n          handleSave();\n        });\n      } else {\n        this.CamanInstance.resize(canvasDimensions);\n\n        this.CamanInstance.render(() => {\n          handleSave();\n        });\n      }\n    });\n  }\n\n  getResizeArguments = ({ width, height } = {}) => `w=${width}&h=${height}`\n\n  /* Adjust */\n\n  initAdjust = () => { }\n\n  onAdjust = (handler, value) => {\n    const { updateState, adjust } = this.props;\n\n    updateState({\n      adjust: {\n        ...adjust,\n        [handler]: value,\n        isHideCanvas: true,\n        isShowSpinner: true,\n      }\n    }, () => {\n      this.applyCorrections(() => {\n        updateState({ isHideCanvas: false, isShowSpinner: false });\n      });\n    });\n  }\n\n  /* Focus point */\n\n  initFocusPoint = () => {\n    const { updateState, original, focusPoint } = this.props;\n    const nextFocusPoint = {...focusPoint};\n\n    if (nextFocusPoint.x === null) {\n      nextFocusPoint.x = original.width / 2;\n    }\n    if (nextFocusPoint.y === null) {\n      nextFocusPoint.y = original.height / 2;\n    }\n\n    this.tempFocusPoint = {...focusPoint};\n    updateState({\n      focusPoint: nextFocusPoint,\n      isHideCanvas: true,\n      isShowSpinner: true,\n    });\n  }\n\n  applyFocusPoint = (callback = () => {}) => {\n    const { updateState, operations, operationsOriginal, focusPoint } = this.props;\n\n    this.tempFocusPoint = focusPoint;\n    updateState({\n      operationsOriginal: [...operationsOriginal, { operation: 'focus_point', props: focusPoint }],\n      operations: [...operations, { operation: 'focus_point', props: focusPoint }],\n    });\n    callback();\n  }\n\n  applyShapes = (callback = () => {}) => {\n    const { shapeOperations } = this.props;\n\n    shapeOperations.updateShapes({ applied: true }, { selectedShape: {} },\n      () => {\n        this.makeCanvasSnapshot({\n        operation: 'shape',\n        props: {\n          shapes: this.props.shapes\n        }\n      }, callback, true);\n    });\n  }\n\n  getFocusPointArguments = focusPoint => `gravity=${focusPoint.x},${focusPoint.y}`;\n\n  destroyFocusPoint = () => {\n    this.props.updateState({\n      focusPoint: this.tempFocusPoint,\n      isHideCanvas: false,\n      isShowSpinner: false,\n    });\n  }\n\n  /* Operation utils */\n\n  pushOperation = (operations, operation, currentOperation) => {\n    const operationIndex = operations.findIndex(operation => operation === currentOperation);\n    const operationsLength = operations.length;\n\n    if (operationsLength && (operationIndex !== operations[operationsLength]))\n      operations.splice(operationIndex + 1, operationsLength);\n\n    operations.push(operation);\n  }\n\n  applyOperations = (operationIndex, callback, operationObject = {}) => {\n    const {\n      initialZoom, operations, operationsZoomed, operationsOriginal, canvasZoomed, canvasOriginal, updateState\n    } = this.props;\n\n    const isZoomed = initialZoom !== 1;\n    const operation = isZoomed ? operationsZoomed[operationIndex] : operations[operationIndex];\n    const hasMoreOperations = operationIndex !== -1;\n\n    // If the operation is previewCanvas one and have the shapes then apply undo or redo\n    if (\n      (operationObject && operationObject.previewCanvas\n        && operationObject.index - 1 === operationIndex)\n      || (operation && operation.previewCanvas\n        && operationObject.index + 1 === operationIndex)\n     ) {\n      const { shapeOperations } = this.props;\n\n      // If the current operation is shape operation replace with its shapes\n      // if not and still there other shape operation in the array replace with last one's shapes\n      // else replace with empty array for shapes.\n      let shapesReplacedWith = operation?.props?.shapes;\n      if (!shapesReplacedWith) {\n        const allShapeOperations = (isZoomed\n          ? operationsZoomed\n          : operations)\n            .filter(\n              (op, index) => op.operation === 'shape' && index < operationObject.index\n            );\n\n        shapesReplacedWith = allShapeOperations.length > 0\n          ? allShapeOperations[allShapeOperations.length - 1].props.shapes\n          : [];\n      }\n      shapeOperations.replaceAllShapes(shapesReplacedWith);\n\n      let nextOperation;\n\n      if (isZoomed) {\n        nextOperation = hasMoreOperations ? operationsZoomed[operationIndex] : { canvas: this.cloneCanvas(canvasZoomed) };\n      } else {\n        nextOperation = hasMoreOperations ? operations[operationIndex] : { canvas: this.cloneCanvas(canvasOriginal) };\n      }\n      \n      updateState({ ...INITIAL_PARAMS, currentOperation: nextOperation }, () => {\n        if (callback) callback();\n      });\n      return;\n    }\n\n    // If no more operations found, then make the shapes array with empty array to reset all shapes.\n    if (!hasMoreOperations) { this.props.shapeOperations.replaceAllShapes([]) }\n\n    if (isZoomed) {\n      const nextOperation = hasMoreOperations ?\n        operationsZoomed[operationIndex] : { canvas: this.cloneCanvas(canvasZoomed) };\n      const canvasZoomedNext = this.replaceCanvas(nextOperation.canvas, CANVAS_ID);\n\n      this.CamanInstanceZoomed = new window.Caman(canvasZoomedNext, () => {\n        updateState({ ...INITIAL_PARAMS, currentOperation: nextOperation }, () => {\n          if (callback) callback();\n        });\n      });\n\n      const nextOperationOriginal = hasMoreOperations ?\n        operationsOriginal[operationIndex] : { canvas: this.cloneCanvas(canvasOriginal) };\n      const canvasNext = this.replaceCanvas(nextOperationOriginal.canvas, ORIGINAL_CANVAS_ID);\n\n      this.CamanInstanceOriginal = new window.Caman(canvasNext, () => {});\n    } else {\n      const nextOperationSimple = hasMoreOperations ?\n        operations[operationIndex] : { canvas: this.cloneCanvas(canvasOriginal) };\n      const canvas = this.replaceCanvas(nextOperationSimple.canvas, CANVAS_ID);\n\n      this.CamanInstance = new window.Caman(canvas, () => {\n        updateState({ ...INITIAL_PARAMS, currentOperation: nextOperationSimple }, () => {\n          if (callback) callback();\n        });\n      });\n    }\n  }\n\n  isOperationExist = (operations, type) => operations.find(({ operation }) => operation === type);\n\n  getOperationQuery = (isCrop, isResize) => {\n    if (isCrop) return 'crop_px';\n    else if (isResize) return 'width';\n    else return 'cdn';\n  }\n\n\n  destroyAll = () => {}\n\n  resetAll = (callback) => {\n    const { activeTab } = this.props;\n\n    if (activeTab) {\n      this.cancelLastOperation(activeTab, () => {\n        this.applyOperations(-1, callback);\n      });\n    } else {\n      this.applyOperations(-1, callback);\n    }\n  }\n\n  applyCorrections = (callback = () => {}) => {\n    const { initialZoom, effect, filter, adjust } = this.props;\n    const { brightness, contrast, saturation, exposure } = adjust;\n\n    if (initialZoom !== 1) {\n      this.CamanInstanceZoomed.revert(false);\n\n      if (effect) this.CamanInstanceZoomed[getEffectHandlerName(effect)]();\n      if (filter) this.CamanInstanceZoomed[getEffectHandlerName(filter)]();\n      if (brightness.toString() !== '0') this.CamanInstanceZoomed.brightness(parseInt(brightness || '0'));\n      if (contrast.toString() !== '0') this.CamanInstanceZoomed.contrast(parseInt(contrast || '0'));\n      if (saturation.toString() !== '0') this.CamanInstanceZoomed.saturation(parseInt(saturation || '0'));\n      if (exposure.toString() !== '0') this.CamanInstanceZoomed.exposure(parseInt(exposure || '0'));\n\n      this.CamanInstanceZoomed.render(callback);\n    } else {\n      this.CamanInstance.revert(false);\n\n      if (effect) this.CamanInstance[getEffectHandlerName(effect)]();\n      if (filter) this.CamanInstance[getEffectHandlerName(filter)]();\n      if (brightness.toString() !== '0') this.CamanInstance.brightness(parseInt(brightness || '0'));\n      if (contrast.toString() !== '0') this.CamanInstance.contrast(parseInt(contrast || '0'));\n      if (saturation.toString() !== '0') this.CamanInstance.saturation(parseInt(saturation || '0'));\n      if (exposure.toString() !== '0') this.CamanInstance.exposure(parseInt(exposure || '0'));\n\n      this.CamanInstance.render(callback);\n    }\n  }\n\n  cancelAddedShapes = () => {\n    const { shapeOperations } = this.props;\n    \n    shapeOperations.deleteShapes({ all: true }, { selectedShape: {} });\n  }\n\n  cancelLastOperation = (activeTab, callback = () => {}) => {\n    const { initialZoom } = this.props;\n\n    if (activeTab === 'crop') {\n      this.destroyCrop();\n    }\n\n    if (activeTab === 'watermark') {\n      this.cancelWatermark();\n    }\n\n    if (['shapes', 'image', 'text'].includes(activeTab)) {\n      this.cancelAddedShapes();\n    }\n\n    if (initialZoom !== 1) {\n      this.CamanInstanceZoomed.reset();\n      this.CamanInstanceOriginal.reset();\n\n      this.CamanInstanceOriginal.render();\n      this.CamanInstanceZoomed.render(() => {\n        if (callback) callback();\n      });\n    } else {\n      this.CamanInstance.reset();\n\n      this.CamanInstance.render(() => {\n        if (callback) callback();\n      });\n    }\n  }\n\n  initWatermark = () => {\n    const { watermark, updateState } = this.props;\n\n\n    if (!watermark.applyByDefault) {\n      updateState({ watermark: { ...watermark, applyByDefault: true } });\n    }\n  }\n\n  applyWatermark = (callback = () => {}) => {\n    const { updateState, shapeOperations } = this.props;\n    const watermarkLayer = (shapeOperations.getShape({ key: WATERMARK_UNIQUE_KEY }) || {}).index;\n\n    this.setState({ tempWatermark: null });\n    updateState({ selectedShape: {} });\n    this.makeCanvasSnapshot({\n      operation: 'shape',\n      props: {\n        shapes: [watermarkLayer]\n      }\n    }, callback, true);\n    callback();\n  }\n\n  cancelWatermark = () => {\n    const { tempWatermark } = this.state;\n    const { updateState, shapeOperations } = this.props;\n    const watermarkLayer = shapeOperations.getShape({ key: WATERMARK_UNIQUE_KEY }) || {};\n    let logoImage = null;\n\n    if (tempWatermark && tempWatermark.url && tempWatermark.applyByDefault) {\n      updateState({ isShowSpinner: true });\n\n      logoImage = new Image();\n      logoImage.setAttribute('crossOrigin', 'Anonymous');\n      logoImage.src = tempWatermark.url + '?' + new Date().getTime();\n\n      logoImage.onload = () => {\n        shapeOperations.updateShape(\n          { img: logoImage, },\n          watermarkLayer.index,\n          { watermark: tempWatermark, logoImage, isShowSpinner: false, selectedShape: {} }\n        );\n      };\n    } else {\n      shapeOperations.deleteShape({ index: watermarkLayer.index }, { watermark: tempWatermark, logoImage, selectedShape: {} });\n    }\n  }\n\n  getWatermarkArguments = () => {\n    const { config: { processWithCloudimage }, shapeOperations } = this.props;\n    const watermarkObj = shapeOperations.getShape({ key: WATERMARK_UNIQUE_KEY });\n    if (!watermarkObj) { return ''; }\n\n    const { x, y, opacity, ...watermark } = watermarkObj;\n    const {\n      original: { width: imgWidth, height: imgHeight } = {}\n    } = this.state;\n    const { width: canvasWidth, height: canvasHeight } = this.getCanvas(PREVIEW_CANVAS_ID);\n\n    const xPos = roundDecimalPoint((x / canvasWidth) * 100);\n    const yPos = roundDecimalPoint((y / canvasHeight) * 100);\n\n    const biggestScaleRatio = Math.max((watermark.width / canvasWidth), (watermark.height / canvasHeight));\n    const watermarkScale = roundDecimalPoint(biggestScaleRatio * 100);\n\n    const gravityQuery = `wat_gravity=absolute&wat_pos=${xPos},${yPos}`;\n    let queryUrl = `wat=1&wat_opacity=${opacity}&wat_scale=${watermarkScale}p&${gravityQuery}`;\n\n    queryUrl += processWithCloudimage && watermark.text\n    ? `&wat_text=${watermark.text}&wat_font=${watermark.textFont}&wat_fontsize=${watermark.textSize}&wat_colour=${watermark.color.replace('#', '')}`\n    : `&wat_url=${watermark.img.src.split('?')[0]}`;\n\n    return queryUrl;\n  };\n\n  applyChanges = (activeTab, callback) => {\n    switch (activeTab) {\n      case 'adjust':\n        this.applyAdjust(callback);\n        break;\n      case 'effects':\n        this.applyFilterOrEffect('effect', callback);\n        break;\n      case 'filters':\n        this.applyFilterOrEffect('filter', callback);\n        break;\n      case 'crop':\n        this.applyCrop(callback);\n        break;\n      case 'resize':\n        this.applyResize();\n        break;\n      case 'rotate':\n        this.applyOrientation(callback);\n        break;\n      case 'watermark':\n        this.applyWatermark(callback);\n        break;\n      case 'focus_point':\n        this.applyFocusPoint(callback);\n        break;\n      case 'shapes':\n      case 'image':\n      case 'text':\n        this.applyShapes(callback);\n        break;\n      default:\n        break;\n    }\n  }\n\n  changeTab = (name) => {\n    switch (name) {\n      case 'effects':\n      case 'filters':\n        this.initFiltersOrEffects();\n        break;\n      case 'adjust':\n        this.initAdjust();\n        break;\n      case 'crop':\n        this.initCrop();\n        break;\n      case 'resize':\n        this.initResize();\n        break;\n      case 'rotate':\n        this.initOrientation();\n        break;\n      case 'watermark':\n        this.initWatermark();\n        break;\n      case 'focus_point':\n        this.initFocusPoint();\n        break;\n      default:\n        this.destroyAll();\n    }\n  }\n\n  destroyMode = (name) => {\n    switch (name) {\n      case 'effects':\n        break;\n      case 'filters':\n        break;\n      case 'adjust':\n        break;\n      case 'crop':\n        this.destroyCrop();\n        break;\n      case 'resize':\n        break;\n      case 'rotate':\n        break;\n      case 'focus_point':\n        this.destroyFocusPoint();\n        break;\n      default:\n        break;\n    }\n  }\n\n  render() {\n    const editorWrapperId = this.props.config.elementId;\n\n    return (\n      <>\n        <Canvas id={`${editorWrapperId}_${ORIGINAL_CANVAS_ID}`} className=\"filerobot-original-canvas\" />\n        <Canvas id={`${editorWrapperId}_${CANVAS_ID}`} className=\"filerobot-edit-canvas\" />\n      </>\n    );\n  }\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Preview\\FocusPointPreview.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Filters.js",["562"],"import React, { Component } from 'react';\nimport { FILTERS } from '../../config';\nimport { EffectsWrapper } from '../../styledComponents';\nimport Filter from './Filter';\n\n\nexport default class extends Component {\n  render() {\n    const { onApplyFilters, filter } = this.props;\n\n    return (\n      <EffectsWrapper>\n        {FILTERS.map(name => <Filter active={filter} key={name} name={name} onApplyFilters={onApplyFilters}/>)}\n      </EffectsWrapper>\n    )\n  }\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Orientation.js",["563"],"import React, { Component } from 'react';\nimport { DarkBtn, OrientationWrapper, RotateButton, RotateIcon, RotateWrapper, ButtonGroup } from '../../styledComponents';\nimport Range from '../Range'\n\n\nexport default class extends Component {\n  leftRotate = () => {\n    const { onRotate, correctionDegree, flipX, flipY } = this.props;\n\n    onRotate(-90, parseInt(correctionDegree), flipX, flipY);\n  }\n\n  rightRotate = () => {\n    const { onRotate, correctionDegree, flipX, flipY } = this.props;\n\n    onRotate(90, parseInt(correctionDegree), flipX, flipY);\n  }\n\n  updateCorrectionDegree = (value) => {\n    const { flipX, flipY } = this.props;\n    this.setState({ correctionDegree: value });\n\n    this.props.onRotate(0, parseFloat(value), flipX, flipY);\n\n  }\n\n  onFlip = (val) => {\n    const { flipX, flipY, correctionDegree } = this.props;\n    const nextFlipXValue = val === 'x' ? !flipX : flipX;\n    const nextFlipYValue = val === 'y' ? !flipY : flipY;\n\n    this.props.onRotate(0, correctionDegree, nextFlipXValue, nextFlipYValue);\n  }\n\n  render() {\n    const { correctionDegree, t, config = {} } = this.props;\n    const { processWithCloudService } = config;\n\n    return (\n      <OrientationWrapper>\n        <RotateWrapper>\n          <RotateButton>\n            <ButtonGroup>\n              <DarkBtn onClick={this.leftRotate}><RotateIcon name=\"left-rotate\"/> <span>{t['orientation.rotate_l']}</span></DarkBtn>\n              <DarkBtn onClick={this.rightRotate}><RotateIcon name=\"right-rotate\"/>\n                <span>{t['orientation.rotate_r']}</span></DarkBtn>\n\n              {!processWithCloudService && (\n                <>\n                  <DarkBtn onClick={() => { this.onFlip('x'); }}><RotateIcon name=\"flip-h\"/>\n                    <span>{t['orientation.flip_h']}</span></DarkBtn>\n                  <DarkBtn onClick={() => { this.onFlip('y'); }}><RotateIcon name=\"flip-v\"/>\n                    <span>{t['orientation.flip_v']}</span></DarkBtn>\n                </>\n              )}\n            </ButtonGroup>\n\n            {!processWithCloudService && (\n            <div>\n              <Range min={-30} max={30} step={0.5} range={correctionDegree} updateRange={this.updateCorrectionDegree}/>\n              <svg viewBox=\"-90 -5 180 10\" xmlns=\"http://www.w3.org/2000/svg\" aria-hidden=\"true\" focusable=\"false\">\n\n                <circle fill=\"currentColor\" cx=\"-37.15555555555556\" cy=\"0\" r=\"0.2\" opacity=\"0.8\"></circle>\n                <circle fill=\"currentColor\" cx=\"-35.2\" cy=\"0\" r=\"0.2\" opacity=\"0.6\"></circle>\n                <circle fill=\"currentColor\" cx=\"-33.24444444444445\" cy=\"0\" r=\"0.2\" opacity=\"0.4\"></circle>\n                <circle fill=\"currentColor\" cx=\"-31.28888888888889\" cy=\"0\" r=\"0.2\" opacity=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"-29.333333333333336\" cy=\"0\" r=\"0.5\"></circle>\n                <text fill=\"currentColor\" x=\"-31.583333333333336\" y=\"3.5\">-30&#176;</text>\n                <circle fill=\"currentColor\" cx=\"-27.37777777777778\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"-25.422222222222224\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"-23.46666666666667\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"-21.51111111111112\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"-19.555555555555557\" cy=\"0\" r=\"0.5\"></circle>\n                <text fill=\"currentColor\" x=\"-21.805555555555557\" y=\"3.5\">-20&#176;</text>\n                <circle fill=\"currentColor\" cx=\"-17.60000000000001\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"-15.644444444444446\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"-13.688888888888897\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"-11.733333333333334\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"-9.777777777777786\" cy=\"0\" r=\"0.5\"></circle>\n                <text fill=\"currentColor\" x=\"-12.027777777777786\" y=\"3.5\">-10&#176;</text>\n                <circle fill=\"currentColor\" cx=\"-7.822222222222223\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"-5.866666666666674\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"-3.9111111111111114\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"-1.9555555555555628\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"0\" cy=\"0\" r=\"0.5\"></circle>\n                <text fill=\"currentColor\" x=\"-0.75\" y=\"3.5\">0&#176;</text>\n                <circle fill=\"currentColor\" cx=\"1.9555555555555486\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"3.9111111111111114\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"5.86666666666666\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"7.822222222222223\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"9.777777777777771\" cy=\"0\" r=\"0.5\"></circle>\n                <text fill=\"currentColor\" x=\"8.277777777777771\" y=\"3.5\">10&#176;</text>\n                <circle fill=\"currentColor\" cx=\"11.733333333333334\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"13.688888888888883\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"15.644444444444446\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"17.599999999999994\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"19.555555555555557\" cy=\"0\" r=\"0.5\"></circle>\n                <text fill=\"currentColor\" x=\"18.055555555555557\" y=\"3.5\">20&#176;</text>\n                <circle fill=\"currentColor\" cx=\"21.511111111111106\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"23.46666666666667\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"25.422222222222217\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"27.37777777777778\" cy=\"0\" r=\"0.2\"></circle>\n                <circle fill=\"currentColor\" cx=\"29.33333333333333\" cy=\"0\" r=\"0.5\"></circle>\n                <text fill=\"currentColor\" x=\"27.83333333333333\" y=\"3.5\">30&#176;</text>\n                <circle fill=\"currentColor\" cx=\"31.28888888888889\" cy=\"0\" r=\"0.2\" opacity=\"0.8\"></circle>\n                <circle fill=\"currentColor\" cx=\"33.24444444444444\" cy=\"0\" r=\"0.2\" opacity=\"0.6\"></circle>\n                <circle fill=\"currentColor\" cx=\"35.2\" cy=\"0\" r=\"0.2\" opacity=\"0.4\"></circle>\n                <circle fill=\"currentColor\" cx=\"37.15555555555555\" cy=\"0\" r=\"0.2\" opacity=\"0.2\"></circle>\n              </svg>\n            </div>\n            )}\n          </RotateButton>\n        </RotateWrapper>\n      </OrientationWrapper>\n    )\n  }\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Effects.js",["564"],"import React, { Component } from 'react';\nimport { EFFECTS } from '../../config';\nimport { EffectsWrapper } from '../../styledComponents';\nimport Effect from './Effect';\n\n\nexport default class extends Component {\n  render() {\n    const { onApplyEffects, effect, noCapitalStrs } = this.props;\n\n    return (\n      <EffectsWrapper>\n        {EFFECTS.map(name => (\n          <Effect\n            active={effect}\n            key={name}\n            name={name}\n            onApplyEffects={onApplyEffects}\n            noCapitalStrs={noCapitalStrs}\n          />\n        ))}\n      </EffectsWrapper>\n    )\n  }\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Crop.js",["565"],"import React, { Component } from 'react';\nimport {\n  CropWrapper, CustomLabel, FieldSet, FieldLabel, FieldInput, BlockRatioWrapper, BlockRatioBtn, BlockRatioIcon,\n  CropBox, CropBoxInner, CropShape, CropLabel, CropShapeWrapper, ShapeAligner, PresetsWrapper\n} from '../../styledComponents';\n\n\n\nexport default class extends Component {\n  state = {\n    aspectRatio: NaN,\n    activeRatio: 'custom'\n  }\n\n  componentDidMount() { }\n\n  changeWidth = (event) => {\n    const { initialZoom } = this.props;\n\n    window.scaleflexPlugins.cropperjs.setCropBoxData({ width: +event.target.value / initialZoom / window.scaleflexPlugins.zoom  });\n  }\n\n\n  changeHeight = (event) => {\n    const { initialZoom } = this.props;\n\n    window.scaleflexPlugins.cropperjs.setCropBoxData({ height: +event.target.value / initialZoom / window.scaleflexPlugins.zoom  });\n  }\n\n  toggleRatio = (event) => {\n    event.preventDefault();\n    event.stopPropagation();\n    const { cropDetails } = this.props;\n    const { width, height } = cropDetails;\n    let aspectRatio = this.state.aspectRatio;\n    aspectRatio = aspectRatio ? NaN : width / height;\n\n    window.scaleflexPlugins.cropperjs.setAspectRatio(aspectRatio);\n    window.scaleflexPlugins.cropperjs.setCropBoxData({\n      width: width / window.scaleflexPlugins.zoom,\n      height: height / window.scaleflexPlugins.zoom\n    });\n    this.setState({ aspectRatio });\n  }\n\n  changeRatio = (box) => {\n    const { aspectRatio } = this.state;\n    const { original: { width = 1, height = 1 }, updateState } = this.props;\n    let value;\n\n    if (box.name === 'custom' && !aspectRatio) {\n      this.setState({ activeRatio: box.name });\n      return;\n    }\n\n    updateState({ roundCrop: box.name === 'round' || box.radius === 50 });\n    value = box.name === 'original' ? width / height : box.value;\n    window.scaleflexPlugins.cropperjs.setAspectRatio(value);\n    this.setState({ activeRatio: box.name, aspectRatio: value });\n  }\n\n  render() {\n    const { aspectRatio, activeRatio } = this.state;\n    const { cropDetails, original, initialZoom, t, config } = this.props;\n    const { cropPresets = [] } = config;\n\n    return (\n      <CropWrapper>\n        <CropBox active={activeRatio === 'custom'}>\n          <FieldSet>\n            <FieldLabel>{t['common.width']}</FieldLabel>\n            <FieldInput\n              dark={activeRatio === 'custom'}\n              fullSize\n              value={Math.round(cropDetails.width * initialZoom)}\n              onChange={this.changeWidth}\n            />\n          </FieldSet>\n          <BlockRatioWrapper>\n            <BlockRatioBtn active={aspectRatio} link onClick={this.toggleRatio}>\n              <BlockRatioIcon active={aspectRatio}/>\n            </BlockRatioBtn>\n          </BlockRatioWrapper>\n          <FieldSet>\n            <FieldLabel>{t['common.height']}</FieldLabel>\n            <FieldInput\n              dark={activeRatio === 'custom'}\n              fullSize\n              value={Math.round(cropDetails.height * initialZoom)}\n              onChange={this.changeHeight}\n            />\n          </FieldSet>\n          <CustomLabel>{t['common.custom']}</CustomLabel>\n        </CropBox>\n\n        <PresetsWrapper>\n          {cropPresets.map(box => (\n            <CropBox\n              active={activeRatio === box.name}\n              onClick={() => { this.changeRatio(box); }}\n              key={box.name}\n            >\n              <CropBoxInner>\n                <CropShapeWrapper>\n                  <ShapeAligner/>\n                  <CropShape ratio={box.value || original.width / original.height} radius={box.radius} />\n                </CropShapeWrapper>\n                <CropLabel>\n                  {t[`common.${box.name}`] || box.name}\n                </CropLabel>\n              </CropBoxInner>\n            </CropBox>\n          ))}\n        </PresetsWrapper>\n      </CropWrapper>\n    )\n  }\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Resize.js",["566"],"import React, { Component } from 'react';\nimport {\n  BlockRatioBtn,\n  BlockRatioIcon,\n  BlockRatioWrapper,\n  FieldInput,\n  FieldLabel,\n  FieldSet,\n  ResizeBox,\n  ResizeWrapper,\n  SuggestionOption,\n  SuggestionsBox\n} from '../../styledComponents';\n\n\nexport default class extends Component {\n  state = {\n    isBlockRatio: false\n  };\n\n  changeWidth = (event) => {\n    const { isBlockRatio } = this.state;\n    const { canvasDimensions } = this.props;\n    const width = event.target.value;\n    let height = canvasDimensions.height;\n\n    if (!isBlockRatio)\n      height = (width && (width / canvasDimensions.ratio)) || 1;\n\n    this.props.updateState({ canvasDimensions: { ...canvasDimensions, width, height } });\n  }\n\n  changeHeight = (event) => {\n    const { isBlockRatio } = this.state;\n    const { canvasDimensions } = this.props;\n    const height = event.target.value;\n    let width = canvasDimensions.width;\n\n    if (!isBlockRatio)\n      width = (height && (height * canvasDimensions.ratio)) || 1;\n\n    this.props.updateState({ canvasDimensions: { ...canvasDimensions, width, height } });\n  }\n\n  applyPreset = ({ width, height }) => {\n    this.props.updateState({ canvasDimensions: { ratio: width / height, width, height } });\n  }\n\n  toggleRatio = () => {\n    this.setState({ isBlockRatio: !this.state.isBlockRatio });\n  }\n\n  render() {\n    const { isBlockRatio } = this.state;\n    const { canvasDimensions, processWithCloudService, t, config } = this.props;\n    const { resizePresets = [] } = config;\n\n    return (\n      <ResizeWrapper>\n        <ResizeBox>\n          <FieldSet>\n            <FieldLabel>{t['common.width']}</FieldLabel>\n            <FieldInput\n              fullSize\n              value={parseInt(canvasDimensions.width, 10) || ''}\n              onChange={this.changeWidth}\n            />\n          </FieldSet>\n          <BlockRatioWrapper>\n            <BlockRatioBtn\n              active={!isBlockRatio}\n              style={processWithCloudService ? { cursor: 'not-allowed' } : {}}\n              link\n              onClick={() => { !processWithCloudService && this.toggleRatio(); }}\n            >\n              <BlockRatioIcon active={!isBlockRatio} style={processWithCloudService ? { cursor: 'not-allowed' } : {}}/>\n            </BlockRatioBtn>\n          </BlockRatioWrapper>\n          <FieldSet>\n            <FieldLabel>{t['common.height']}</FieldLabel>\n            <FieldInput\n              fullSize\n              value={parseInt(canvasDimensions.height, 10) || ''}\n              onChange={this.changeHeight}\n            />\n          </FieldSet>\n        </ResizeBox>\n        <SuggestionsBox>\n          {resizePresets\n            .filter(preset =>\n              Math.abs(canvasDimensions.width / canvasDimensions.height - preset.ratio) < 0.05\n            )\n            .map(preset => (\n              <SuggestionOption key={preset.name} onClick={() => { this.applyPreset(preset); }}>\n                <div>{preset.width} x {preset.height}</div>\n                <div>{preset.name}</div>\n              </SuggestionOption>\n            ))}\n        </SuggestionsBox>\n      </ResizeWrapper>\n    )\n  }\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Adjust.js",["567"],"import React, { Component } from 'react';\nimport { AdjustWrapper } from '../../styledComponents';\nimport Range from '../Range';\n\n\nexport default class extends Component {\n  constructor(){\n    super();\n\n    this.state = {\n      brightness: 0,\n      contrast: 0,\n      exposure: 0,\n      saturation: 0\n    };\n  }\n\n  updateBrightness = (value) => {\n    this.onAdjust('brightness', value);\n  }\n\n  updateContrast = (value) => {\n    this.onAdjust('contrast', value);\n  }\n\n  updateExposure = (value) => {\n    this.onAdjust('exposure', value);\n  }\n\n  updateSaturation = (value) => {\n    this.onAdjust('saturation', value);\n  }\n\n  onAdjust = (type, value) => {\n    this.setState({ [type]: value });\n    this.props.onAdjust(type, value);\n  }\n\n  render () {\n    const { t } = this.props;\n    const { brightness, contrast, exposure, saturation } = this.state;\n\n    return (\n      <AdjustWrapper>\n        <Range label={t['adjust.brightness']} range={brightness} updateRange={this.updateBrightness}/>\n        <Range label={t['adjust.contrast']} range={contrast} updateRange={this.updateContrast}/>\n        <Range label={t['adjust.exposure']} range={exposure} updateRange={this.updateExposure}/>\n        <Range label={t['adjust.saturation']} range={saturation} updateRange={this.updateSaturation}/>\n      </AdjustWrapper>\n    );\n  }\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Watermark.js",["568","569"],"import React, { Component } from 'react';\nimport {\n  FieldInput,\n  FileInput,\n  PositionSquare,\n  WatermarkIcon,\n  WatermarkInputs,\n  WatermarkInputTypes,\n  WatermarkPositionWrapper,\n  Watermarks,\n  WatermarkWrapper,\n  WrapperForControls,\n  WrapperForOpacity,\n  WrapperForURL\n} from '../../styledComponents';\nimport { debounce } from 'throttle-debounce';\nimport Range from '../Range';\nimport Select from '../Shared/Select';\nimport {\n  WATERMARK_POSITIONS,\n  WATERMARK_POSITIONS_PRESET,\n  WATERMARK_CLOUDIMAGE_FONTS,\n  WATERMARK_UNIQUE_KEY,\n  SHAPES_VARIANTS\n} from '../../config';\nimport { getWatermarkSquaredPosition, getCanvasNode } from '../../utils';\n\n\nexport default class extends Component {\n  constructor(props) {\n    super(props);\n    const { opacity, position, url, applyByDefault, activePositions, handleOpacity } = props.watermark;\n    let { urls, fonts } = props.watermark;\n\n    let setActivePositions = [];\n    let activePosition = position || 'right-top';\n\n    // check if a preset was selected\n    if (typeof activePositions === 'string' && WATERMARK_POSITIONS_PRESET.hasOwnProperty(activePositions)) {\n      setActivePositions = WATERMARK_POSITIONS_PRESET[activePositions];\n    }\n\n    // check if activePositons is an array\n    else if (Array.isArray(activePositions)) {\n      const fullPos = Array(9).fill(0);\n      // merge with an default of 9 to prevent errors when the length is lower 9\n      activePositions.map((val, i) => fullPos[i] = val);\n      setActivePositions = fullPos;\n\n      // return the default that all positions are active\n    } else {\n      setActivePositions = Array(9).fill(1);\n    }\n\n    // check if position is active else set the first upcomming active as the new active position\n    if (setActivePositions[WATERMARK_POSITIONS.indexOf(activePosition)] !== 1) {\n      activePosition = WATERMARK_POSITIONS[setActivePositions.indexOf(1)];\n    }\n\n    if (urls) {\n      urls = urls.map((url = '') => {\n        if (typeof url === 'string') {\n          const splittedURL = url.split('/');\n\n          return { url, label: splittedURL[splittedURL.length - 1] }\n        } else {\n          return url;\n        }\n      })\n    }\n\n    this.initWatermarkImage(url || urls?.[0]?.url);\n\n    this.state = {\n      isBlockRatio: false,\n      opacity: opacity || 0.7,\n      handleOpacity: typeof handleOpacity === 'boolean' ? handleOpacity : true,\n      position: activePosition,\n      url: url || (urls && urls.length > 1 ? urls[0] && urls[0].url : ''),\n      urls: urls || [],\n      activePositions: setActivePositions,\n      isWatermarkList: urls && urls.length > 1,\n      applyByDefault: applyByDefault || false,\n      showWaterMarkList: false,\n      selectedInputType: urls && urls.length > 1 ? 'gallery' : 'upload',\n      text: '',\n      color: '#000000',\n      textSize: 62,\n      textFont: 'Arial',\n      fonts: fonts || this.props.config.theme.fonts,\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    const nextProps = this.props;\n    // check if position has ben modified and update\n    if (nextProps.watermark.position !== this.state.position) {\n      this.onPositionChange(this.state.position);\n    }\n    if (nextProps.watermark.applyByDefault !== prevProps.watermark.applyByDefault) {\n      if (this.getWatermarkLayer()) {\n        this.updateWatermarkProperty(\n          { applyByDefault: false },\n          { hidden: true, resizingBox: false },\n          { applyByDefault: false }\n        );\n      } else {\n        this.setState({ applyByDefault: nextProps.watermark.applyByDefault });\n      }\n\n      if (nextProps.watermark.applyByDefault) {\n        if (!this.getWatermarkLayer()) {\n          this.initWatermarkImage(nextProps.watermark.url);\n        } else {\n          this.updateWatermarkProperty(\n            { applyByDefault: true },\n            { hidden: false, resizingBox: true },\n            { applyByDefault: true }\n          );\n        }\n      }\n    }\n  }\n\n  changeOpacity = (opacity) => {\n    this.updateWatermarkProperty({ opacity });\n  }\n\n  updateWatermarkProperty = (data, shapeData, watermarkObjectData) => {\n    const {\n      shapeOperations,\n      watermark: { lockScaleToPercentage = 0 }\n    } = this.props;\n    if (!shapeData) { shapeData = data }\n    if (!watermarkObjectData) { watermarkObjectData = data }\n\n    const watermark = this.getWatermarkLayer() || {};\n    this.setState(data, () => {\n      shapeOperations.addOrUpdate(\n        { ...shapeData, lockScaleToPercentage, key: WATERMARK_UNIQUE_KEY, index: watermark.index, tab: 'watermark' },\n        {\n          watermark: {\n            ...this.props.watermark,\n            ...watermarkObjectData\n          }\n        }\n      );\n    });\n  }\n\n  getWatermarkLayer = () => {\n    const { shapeOperations } = this.props;\n    return shapeOperations.getShape({ key: WATERMARK_UNIQUE_KEY });\n  }\n\n  changeURL = (event, shapeData = {}) => {\n    const nextValue = event.target.value;\n\n    if (this.props.watermark.text) {\n      this.initWatermarkImage(nextValue);\n      return;\n    }\n\n    const position = this.state.position;\n\n    this.updateWatermarkProperty({ url: nextValue, position }, { img: nextValue, position, ...shapeData }, { url: '', text: false })\n  }\n\n  changeTextProperty = (event) => {\n    const updatedProperty = { [event.target.name]: event.target.value };\n\n    if (this.props.watermark.text) {\n      this.updateWatermarkProperty(updatedProperty);\n      return;\n    }\n\n    const { text, color, textSize, textFont, opacity } = this.state;\n\n    const newWatermarkData = {\n      text,\n      color,\n      textSize,\n      textFont,\n      opacity,\n      variant: SHAPES_VARIANTS.TEXT,\n      tab: 'watermark',\n      ...updatedProperty\n    };\n\n    this.updateWatermarkProperty(\n      { ...updatedProperty },\n      { ...newWatermarkData, resizingBox: true },\n      { text: { ...this.props.watermark.text, ...newWatermarkData } },\n    );\n  }\n\n  readFile = (event) => {\n    const { config } = this.props;\n    // Disable uploading file processing if it's through cloudimage\n    if (config.processWithCloudimage) return null;\n    \n    const input = event.target;\n    if (input.files && input.files[0]) {\n      const reader = new FileReader();\n      reader.onload = (e) => {\n        this.changeURL({ target: { value: e.target.result } }, { variant: SHAPES_VARIANTS.IMAGE });\n      }\n      reader.readAsDataURL(input.files[0]);\n    }\n  }\n\n  getWatermarkDimensionsByPosString = (positionString, width, height) => {\n    return getWatermarkSquaredPosition(positionString, getCanvasNode(this.props.config.elementId), width, height);\n  }\n\n  onPositionChange = value => {\n    const { width, height } = this.getWatermarkLayer();\n    const [\n      x,\n      y,\n      scaledWidth,\n      scaledHeight\n    ] = this.getWatermarkDimensionsByPosString(value, width, height);\n    this.updateWatermarkProperty(\n      { position: value, width: scaledWidth, height: scaledHeight },\n      { x, y, width: scaledWidth, height: scaledHeight },\n      { position: value, x, y, width: scaledWidth, height: scaledHeight });\n  }\n\n  initWatermarkImage = debounce(500, (url) => {\n    const { updateState } = this.props;\n    let logoImage = null;\n\n    updateState({ isShowSpinner: true });\n\n    const watermarkImageState = (newImage) => ({\n        logoImage: newImage,\n        isShowSpinner: false,\n        watermark: { ...this.props.watermark, url: newImage.src }\n    });\n\n    if (url) {\n      const {\n        shapeOperations,\n        watermark: { lockScaleToPercentage = 0, position }\n      } = this.props;\n      const { opacity } = this.state;\n\n      logoImage = new Image();\n      logoImage.setAttribute('crossOrigin', 'Anonymous');\n\n      logoImage.onload = () => {\n        const { imageFilter } = this.props.watermark;\n        let watermarkImageStateObj;\n        if (imageFilter && typeof imageFilter === 'function') {\n          logoImage.onload = null;\n          watermarkImageStateObj = watermarkImageState(imageFilter(logoImage));\n        } else {\n          watermarkImageStateObj = watermarkImageState(logoImage);\n        }\n\n        const index = (this.getWatermarkLayer() || {}).index;\n\n        const [x, y, width,height] = this.getWatermarkDimensionsByPosString(position, logoImage.width, logoImage.height);\n\n        shapeOperations.addOrUpdate({\n          img: logoImage,\n          opacity,\n          index,\n          x,\n          y,\n          width,\n          height,\n          variant: SHAPES_VARIANTS.IMAGE,\n          key: WATERMARK_UNIQUE_KEY,\n          tab: 'watermark',\n          lockScaleToPercentage\n        }, watermarkImageStateObj);\n      }\n\n      logoImage.onerror = () => {\n        updateState({ isShowSpinner: false });\n      }\n\n      if (url.match(/^https?:\\/\\/./)) {\n        // if the url is a HTTP URL add a cache breaker\n        logoImage.src = url + '?' + new Date().getTime();\n      } else {\n        logoImage.src = url;\n      }\n    } else {\n      updateState({ isShowSpinner: false });\n    }\n  });\n\n  showWatermarkList = () => {\n    this.setState({ showWaterMarkList: true });\n  }\n\n  hideWatermarkList = () => {\n    this.setState({ showWaterMarkList: false });\n  }\n\n  onChangeWatermark = (url) => {\n    this.changeURL({ target: { value: url } });\n    this.hideWatermarkList();\n  }\n\n  handleInputTypeChange = ({ target }) => {\n    const { updateState, config } = this.props;\n    updateState({ isShowSpinner: true });\n\n    this.setState({ selectedInputType: target.value });\n    if (target.value === 'text') {\n      this.changeTextProperty({\n        target: {\n          name: 'text',\n          value: (config.watermark || {}).defaultText || 'Your text'\n        }\n      })\n      updateState({ isShowSpinner: false })\n    } else {\n      updateState({ watermark: {...this.props.watermark, text: null } });\n      this.initWatermarkImage(this.props.watermark.url || '')\n    }\n  }\n\n  render() {\n    const {\n      isWatermarkList,\n      url,\n      urls,\n      opacity,\n      handleOpacity,\n      position,\n      activePositions,\n      applyByDefault,\n      showWaterMarkList,\n      selectedInputType,\n      text,\n      color,\n      textFont,\n      textSize,\n      fonts,\n    } = this.state;\n    const { config } = this.props;\n    const fileUploadInput = selectedInputType === 'upload';\n    const galleryInput = selectedInputType === 'gallery';\n    const urlInput = selectedInputType === 'url';\n    const textInput = selectedInputType === 'text';\n    const { t } = this.props;\n\n    return (\n      <WatermarkWrapper>\n\n        <WatermarkInputTypes>\n          <label>\n            {t['common.gallery']}\n            <input\n              type=\"radio\"\n              value=\"gallery\"\n              checked={selectedInputType === 'gallery'}\n              onChange={this.handleInputTypeChange}\n            />\n            <span/>\n          </label>\n          <label style={{ cursor: config.processWithCloudimage ? 'not-allowed' : 'auto' }}>\n            {t['common.upload']}\n            <input\n              type=\"radio\"\n              value=\"upload\"\n              checked={selectedInputType === 'upload'}\n              disabled={config.processWithCloudimage}\n              onChange={this.handleInputTypeChange}/>\n            <span/>\n          </label>\n          <label>\n            {t['common.url']}\n            <input\n              type=\"radio\"\n              value=\"url\"\n              checked={selectedInputType === 'url'}\n              onChange={this.handleInputTypeChange}/>\n            <span/>\n          </label>\n          <label>\n            {t['common.text']}\n            <input\n              type=\"radio\"\n              value=\"text\"\n              checked={selectedInputType === 'text'}\n              onChange={this.handleInputTypeChange}/>\n            <span/>\n          </label>\n        </WatermarkInputTypes>\n\n        <WatermarkInputs>\n          <WrapperForURL>\n            {galleryInput && (<>\n              <label htmlFor=\"url\">Watermark Gallery</label>\n              <Select\n                width=\"100%\"\n                list={urls}\n                valueProp=\"url\"\n                id=\"gallery\"\n                value={url}\n                style={{ width: 'calc(100% - 120px)' }}\n                onChange={(url) => { this.changeURL({ target: { value: url } }) }}\n              />\n            </>)}\n            {urlInput && (<>\n              <label htmlFor=\"url\">Watermark URL</label>\n              <FieldInput\n                id=\"url\"\n                value={url}\n                style={{ width: 'calc(100% - 120px)' }}\n                onChange={this.changeURL}\n              />\n            </>)}\n            {fileUploadInput && (<>\n              <label htmlFor=\"image-upload\">Watermark Image</label>\n              <FileInput\n                id=\"image-upload\"\n                style={{ width: 'calc(100% - 120px)' }}\n                onChange={this.readFile}\n              />\n            </>)}\n            {textInput && (<>\n              <label htmlFor=\"text\">Watermark Text</label>\n              <FieldInput\n                id=\"text\"\n                value={text}\n                style={{ width: 'calc(65% - 135px)', minWidth: 120 }}\n                name=\"text\"\n                onChange={this.changeTextProperty}\n              />\n              <Select\n                list={config.processWithCloudimage ? WATERMARK_CLOUDIMAGE_FONTS : fonts}\n                valueProp=\"value\"\n                id=\"textFont\"\n                value={textFont}\n                style={{ width: 111, display: 'inline-block', marginLeft: 8 }}\n                onChange={(value) => this.changeTextProperty({ target: { name: 'textFont', value } })}\n              />\n              <FieldInput\n                value={textSize}\n                type=\"number\"\n                name=\"textSize\"\n                style={{ width: 60, marginLeft: 8 }}\n                onChange={this.changeTextProperty}\n              />\n              <FieldInput\n                value={color}\n                type=\"color\"\n                style={{ width: 30, marginLeft: 8, padding: 0, background: 'transparent', boxShadow: 'none' }}\n                name=\"color\"\n                onChange={this.changeTextProperty}\n              />\n            </>)}\n          </WrapperForURL>\n          <WrapperForControls switcherPosition={handleOpacity ? 'right' : 'left'}>\n            {handleOpacity &&\n            <WrapperForOpacity>\n              <label htmlFor=\"opacity\" style={{ minWidth: 80 }}>Opacity</label>\n              <Range\n                label={t['common.opacity']}\n                min={0}\n                max={1}\n                step={0.05}\n                range={opacity}\n                updateRange={this.changeOpacity}\n              />\n            </WrapperForOpacity>\n            }\n          </WrapperForControls>\n        </WatermarkInputs>\n\n        <WatermarkPositionWrapper>\n          {WATERMARK_POSITIONS.map((value, index) => (\n            <PositionSquare\n              key={value}\n              value={value}\n              active={value === position}\n              clickable={activePositions[index]}\n              onClick={() => {\n                if (activePositions[index]) {\n                  this.onPositionChange(value);\n                }\n              }}\n            />\n          ))}\n        </WatermarkPositionWrapper>\n\n        {isWatermarkList && showWaterMarkList && (\n          <Watermarks>\n            {urls.map(url => <WatermarkIcon key={url} src={url} onClick={() => { this.onChangeWatermark(url) }}/>)}\n          </Watermarks>\n        )}\n\n      </WatermarkWrapper>\n    )\n  }\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\FocusPoint.js",["570"],"import React, { Component } from 'react';\nimport { ResizeWrapper, FieldSet, FieldLabel, FieldInput, ResizeBox } from '../../styledComponents';\n\n\nexport default class extends Component {\n  componentDidMount() { }\n\n  changeWidth = ({target: {value}}) => {\n    const { updateState, focusPoint, canvasDimensions } = this.props;\n    const newFocusPoint = {\n      ...focusPoint,\n      x: Math.min(isNaN(value) ? 0 : +value, canvasDimensions.width)\n    };\n\n    updateState({focusPoint: newFocusPoint});\n  }\n\n\n  changeHeight = ({target: {value}}) => {\n    const { updateState, focusPoint, canvasDimensions } = this.props;\n    const newFocusPoint = {\n      ...focusPoint,\n      y: Math.min(isNaN(value) ? 0 : +value, canvasDimensions.height)\n    };\n\n    updateState({focusPoint: newFocusPoint});\n  }\n\n  render() {\n    const { focusPoint, t } = this.props;\n\n    return (\n      <ResizeWrapper>\n        <ResizeBox active>\n          <FieldSet>\n            <FieldLabel>{t['common.x']}</FieldLabel>\n            <FieldInput\n              dark\n              fullSize\n              value={Math.round(focusPoint.x)}\n              onChange={this.changeWidth}\n            />\n          </FieldSet>\n          &nbsp;&nbsp;\n          <FieldSet>\n            <FieldLabel>{t['common.y']}</FieldLabel>\n            <FieldInput\n              dark\n              fullSize\n              value={Math.round(focusPoint.y)}\n              onChange={this.changeHeight}\n            />\n          </FieldSet>\n        </ResizeBox>\n      </ResizeWrapper>\n    )\n  }\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Text.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Shapes.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Image.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\index.js",["571","572","573","574","575","576","577","578","579","580","581","582","583","584","585","586","587","588","589","590","591","592","593","594","595","596","597","598","599","600","601"],"import Module from './module';\nimport { Util, $ } from '../core/util';\nimport { Log } from './logger';\nimport Store from './store';\nimport Renderer from './renderer';\n\n/*\n * decaffeinate suggestions:\n * DS001: Remove Babel/TypeScript constructor workaround\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS202: Simplify dynamic range loops\n * DS203: Remove `|| {}` from converted for-own loops\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS206: Consider reworking classes to avoid initClass\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n\n// Here it begins. Caman is defined.\n// There are many different initialization for Caman, which are described on the\n// [Guides](http://camanjs.com/guides).\n//\n// Initialization is tricky because we need to make sure everything we need is actually fully\n// loaded in the DOM before proceeding. When initialized on an image, we need to make sure that the\n// image is done loading before converting it to a canvas element and writing the pixel data. If we\n// do this prematurely, the browser will throw a DOM Error, and chaos will ensue. In the event that\n// we initialize Caman on a canvas element while specifying an image URL, we need to create a new\n// image element, load the image, then continue with initialization.\n//\n// The main goal for Caman was simplicity, so all of this is handled transparently to the end-user.\nclass Caman extends Module {\n  static initClass() {\n    // The current version.\n    this.version = {\n      release: \"4.1.2\",\n      date: \"7/27/2013\"\n    };\n\n    // @property [Boolean] Debug mode enables console logging.\n    this.DEBUG = false;\n\n    // @property [Boolean] Allow reverting the canvas?\n    //   If your JS process is running out of memory, disabling\n    //   this could help drastically.\n    this.allowRevert = true;\n\n    // @property [String] Default cross-origin policy.\n    this.crossOrigin = \"anonymous\";\n\n    // @property [String] Set the URL of the image proxy script.\n    this.remoteProxy = \"\";\n\n    // @proparty [String] The GET param used with the proxy script.\n    this.proxyParam = \"camanProxyUrl\";\n\n    // @property [Boolean] Should we check the DOM for images with Caman instructions?\n    this.autoload = true;\n\n    // @property [Integer] to know how many angles was the image rotated so I can get the correct imageData when rotate the new canvas\n    this.angle = 0;\n\n    // @property [Boolean]  if canvas was rotated\n    this.rotated = false;\n  }\n\n  // Custom toString()\n  // @return [String] Version and release information.\n  static toString() {\n    return `Version ${Caman.version.release}, Released ${Caman.version.date}`;\n  }\n\n  // Get the ID assigned to this canvas by Caman.\n  // @param [DOMObject] canvas The canvas to inspect.\n  // @return [String] The Caman ID associated with this canvas.\n  static getAttrId(canvas) {\n    if (typeof canvas === \"string\") {\n      canvas = $(canvas);\n    }\n\n    if ((canvas == null) || (canvas.getAttribute == null)) { return null; }\n    return canvas.getAttribute('data-caman-id');\n  }\n\n  // The Caman function. While technically a constructor, it was made to be called without\n  // the `new` keyword. Caman will figure it out.\n  //\n  // @param [DOMObject, String] initializer The DOM selector or DOM object to initialize.\n  // @overload Caman(initializer)\n  //   Initialize Caman without a callback.\n  //\n  // @overload Caman(initializer, callback)\n  //   Initialize Caman with a callback.\n  //   @param [Function] callback Function to call once initialization completes.\n  //\n  // @overload Caman(initializer, url)\n  //   Initialize Caman with a URL to an image and no callback.\n  //   @param [String] url URl to an image to draw to the canvas.\n  //\n  // @overload Caman(initializer, url, callback)\n  //   Initialize Caman with a canvas, URL to an image, and a callback.\n  //   @param [String] url URl to an image to draw to the canvas.\n  //   @param [Function] callback Function to call once initialization completes.\n  //\n  // @overload Caman(file)\n  //   **NodeJS**: Initialize Caman with a path to an image file and no callback.\n  //   @param [String, File] file File object or path to image to read.\n  //\n  // @overload Caman(file, callback)\n  //   **NodeJS**: Initialize Caman with a file and a callback.\n  //   @param [String, File] file File object or path to image to read.\n  //   @param [Function] callback Function to call once initialization completes.\n  //\n  // @return [Caman] Initialized Caman instance.\n  constructor() {\n    {\n      // Hack: trick Babel/TypeScript into allowing this before super.\n      if (false) { super(); }\n      let thisFn = (() => { return this; }).toString();\n      let thisName = thisFn.match(/return (?:_assertThisInitialized\\()*(\\w+)\\)*;?/)[1];\n      eval(`${thisName} = this;`);\n    }\n    if (arguments.length === 0) { throw \"Invalid arguments\"; }\n\n    if (this instanceof Caman) {\n      // We have to do this to avoid polluting the global scope\n      // because of how Coffeescript binds functions specified\n      // with => and the fact that Caman can be invoked as both\n      // a function and as a 'new' object.\n      let id;\n      this.finishInit = this.finishInit.bind(this);\n      this.imageLoaded = this.imageLoaded.bind(this);\n\n      const args = Array.prototype.slice.call(arguments, 0);\n\n      id = parseInt(Caman.getAttrId(args[0]), 10);\n      const callback = typeof args[1] === \"function\" ?\n        args[1]\n        : typeof args[2] === \"function\" ?\n          args[2]\n          :\n          function() {};\n\n      if (!isNaN(id) && Store.has(id)) {\n        return Store.execute(id, callback);\n      }\n\n      // Every instance gets a unique ID. Makes it much simpler to check if two variables are the\n      // same instance.\n      this.id = Util.uniqid.get();\n\n      this.initializedPixelData = (this.originalPixelData = null);\n      this.cropCoordinates = {x: 0, y: 0};\n      this.cropped = false;\n      this.resized = false;\n\n      this.pixelStack = [];  // Stores the pixel layers\n      this.layerStack = [];  // Stores all of the layers waiting to be rendered\n      this.canvasQueue = []; // Stores all of the canvases to be processed\n      this.currentLayer = null;\n      this.scaled = false;\n\n      //this.analyze = new Analyze(this);\n      this.renderer = new Renderer(this);\n\n      this.domIsLoaded(() => {\n        this.parseArguments(args);\n        return this.setup();\n      });\n\n      return this;\n    } else {\n      return new Caman(arguments);\n    }\n  }\n\n  // Checks to ensure the DOM is loaded. Ensures the callback is always fired, even\n  // if the DOM is already loaded before it's invoked. The callback is also always\n  // called asynchronously.\n  //\n  // @param [Function] cb The callback function to fire when the DOM is ready.\n  domIsLoaded(cb) {\n    if (document.readyState === \"complete\") {\n      Log.debug(\"DOM initialized\");\n      return setTimeout(() => {\n          return cb.call(this);\n        }\n        , 0);\n    } else {\n      const listener = () => {\n        if (document.readyState === \"complete\") {\n          Log.debug(\"DOM initialized\");\n          return cb.call(this);\n        }\n      };\n\n      return document.addEventListener(\"readystatechange\", listener, false);\n    }\n  }\n\n  // Parses the arguments given to the Caman function, and sets the appropriate\n  // properties on this instance.\n  //\n  // @params [Array] args Array of arguments passed to Caman.\n  parseArguments(args) {\n    if (args.length === 0) { throw \"Invalid arguments given\"; }\n\n    // Defaults\n    this.initObj = null;\n    this.initType = null;\n    this.imageUrl = null;\n    this.callback = function() {};\n\n    // First argument is always our canvas/image\n    this.setInitObject(args[0]);\n    if (args.length === 1) { return; }\n\n    switch (typeof args[1]) {\n      case \"string\": this.imageUrl = args[1]; break;\n      case \"function\": this.callback = args[1]; break;\n    }\n\n    if (args.length === 2) { return; }\n\n    this.callback = args[2];\n\n    if (args.length === 4) {\n      return (() => {\n        const result = [];\n        for (let key of Object.keys(args[4] || {})) {\n          const val = args[4][key];\n          result.push(this.options[key] = val);\n        }\n        return result;\n      })();\n    }\n  }\n\n  // Sets the initialization object for this instance.\n  //\n  // @param [Object, String] obj The initialization argument.\n  setInitObject(obj) {\n    if (typeof obj === \"object\") {\n      this.initObj = obj;\n    } else {\n      this.initObj = $(obj);\n    }\n\n    if (this.initObj == null) { throw \"Could not find image or canvas for initialization.\"; }\n\n    return this.initType = this.initObj.nodeName.toLowerCase();\n  }\n\n  // Begins the setup process, which differs depending on whether we're in NodeJS,\n  // or if an image or canvas object was provided.\n  setup() {\n    switch (this.initType) {\n      case \"node\": return this.initNode();\n      case \"img\": return this.initImage();\n      case \"canvas\": return this.initCanvas();\n    }\n  }\n\n  // Initialization function for the browser and image objects.\n  initImage() {\n    this.image = this.initObj;\n    this.canvas = document.createElement('canvas');\n    this.context = this.canvas.getContext('2d');\n    Util.copyAttributes(this.image, this.canvas, {except: ['src']});\n\n    // Swap out the image with the canvas element if the image exists\n    // in the DOM.\n    if (this.image.parentNode != null) { this.image.parentNode.replaceChild(this.canvas, this.image); }\n\n    this.imageAdjustments();\n    return this.waitForImageLoaded();\n  }\n\n  // Initialization function for the browser and canvas objects.\n  initCanvas() {\n    this.canvas = this.initObj;\n    this.context = this.canvas.getContext('2d');\n\n    if (this.imageUrl != null) {\n      this.image = document.createElement('img');\n      this.image.src = this.imageUrl;\n\n      this.imageAdjustments();\n      return this.waitForImageLoaded();\n    } else {\n      return this.finishInit();\n    }\n  }\n\n  // Automatically check for a HiDPI capable screen and swap out the image if possible.\n  // Also checks the image URL to see if it's a cross-domain request, and attempt to\n  // proxy the image. If a cross-origin type is configured, the proxy will be ignored.\n  imageAdjustments() {\n    if (this.needsHiDPISwap()) {\n      Log.debug(this.image.src, \"->\", this.hiDPIReplacement());\n\n      this.swapped = true;\n      this.image.src = this.hiDPIReplacement();\n    }\n\n    if (Caman.IO.isRemote(this.image)) {\n      this.image.src = Caman.IO.proxyUrl(this.image.src);\n      return Log.debug(`Remote image detected, using URL = ${this.image.src}`);\n    }\n  }\n\n  // Utility function that fires {Caman#imageLoaded} once the image is finished loading.\n  waitForImageLoaded() {\n    if (this.isImageLoaded()) {\n      return this.imageLoaded();\n    } else {\n      return this.image.onload = this.imageLoaded;\n    }\n  }\n\n  // Checks if the given image is finished loading.\n  // @return [Boolean] Is the image loaded?\n  isImageLoaded() {\n    if (!this.image.complete) { return false; }\n\n    // Internet Explorer is weird.\n    if ((this.image.naturalWidth != null) && (this.image.naturalWidth === 0)) { return false; }\n    return true;\n  }\n\n  // Internet Explorer has issues figuring out image dimensions when they aren't\n  // explicitly defined, apparently. We check the normal width/height properties first,\n  // but fall back to natural sizes if they are 0.\n  // @return [Number] Width of the initialization image.\n  imageWidth() { return this.image.width || this.image.naturalWidth; }\n\n  // @see Caman#imageWidth\n  // @return [Number] Height of the initialization image.\n  imageHeight() { return this.image.height || this.image.naturalHeight; }\n\n  // Function that is called once the initialization image is finished loading.\n  // We make sure that the canvas dimensions are properly set here.\n  imageLoaded() {\n    Log.debug(`Image loaded. Width = ${this.imageWidth()}, Height = ${this.imageHeight()}`);\n\n    if (this.swapped) {\n      this.canvas.width = this.imageWidth() / this.hiDPIRatio();\n      this.canvas.height = this.imageHeight() / this.hiDPIRatio();\n    } else {\n      this.canvas.width = this.imageWidth();\n      this.canvas.height = this.imageHeight();\n    }\n\n    return this.finishInit();\n  }\n\n  // Final step of initialization. We finish setting up our canvas element, and we\n  // draw the image to the canvas (if applicable).\n  finishInit() {\n    if (this.context == null) { this.context = this.canvas.getContext('2d'); }\n\n    this.originalWidth = (this.preScaledWidth = (this.width = this.canvas.width));\n    this.originalHeight = (this.preScaledHeight = (this.height = this.canvas.height));\n\n    this.hiDPIAdjustments();\n    if (!this.hasId()) { this.assignId(); }\n\n    if (this.image != null) {\n      this.context.drawImage(this.image,\n        0, 0,\n        this.imageWidth(), this.imageHeight(),\n        0, 0,\n        this.preScaledWidth, this.preScaledHeight);\n    }\n\n    this.imageData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);\n    this.pixelData = this.imageData.data;\n\n    if (Caman.allowRevert) {\n      this.initializedPixelData = Util.dataArray(this.pixelData.length);\n      this.originalPixelData = Util.dataArray(this.pixelData.length);\n\n      for (let i = 0; i < this.pixelData.length; i++) {\n        const pixel = this.pixelData[i];\n        this.initializedPixelData[i] = pixel;\n        this.originalPixelData[i] = pixel;\n      }\n    }\n\n    this.dimensions = {\n      width: this.canvas.width,\n      height: this.canvas.height\n    };\n\n    Store.put(this.id, this);\n    this.callback.call(this,this);\n\n    // Reset the callback so re-initialization doesn't\n    // trigger it again.\n    return this.callback = function() {};\n  }\n\n  // If you have a separate context reference to this canvas outside of CamanJS\n  // and you make a change to the canvas outside of CamanJS, you will have to call\n  // this function to update our context reference to include those changes.\n  reloadCanvasData() {\n    this.imageData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);\n    return this.pixelData = this.imageData.data;\n  }\n\n  // Reset the canvas pixels to the original state at initialization.\n  resetOriginalPixelData() {\n    if (!Caman.allowRevert) { throw \"Revert disabled\"; }\n\n    this.originalPixelData = Util.dataArray(this.pixelData.length);\n    return Array.from(this.pixelData).map((pixel, i) => (this.originalPixelData[i] = pixel));\n  }\n\n  // Does this instance have an ID assigned?\n  // @return [Boolean] Existance of an ID.\n  hasId() { return (Caman.getAttrId(this.canvas) != null); }\n\n  // Assign a unique ID to this instance.\n  assignId() {\n    if (this.canvas.getAttribute('data-caman-id')) { return; }\n    return this.canvas.setAttribute('data-caman-id', this.id);\n  }\n\n  // Is HiDPI support disabled via the HTML data attribute?\n  // @return [Boolean]\n  hiDPIDisabled() {\n    return this.canvas.getAttribute('data-caman-hidpi-disabled') !== null;\n  }\n\n  // Perform HiDPI adjustments to the canvas. This consists of changing the\n  // scaling and the dimensions to match that of the display.\n  hiDPIAdjustments() {\n    if (!this.needsHiDPISwap()) { return; }\n\n    const ratio = this.hiDPIRatio();\n\n    if (ratio !== 1) {\n      Log.debug(`HiDPI ratio = ${ratio}`);\n      this.scaled = true;\n\n      this.preScaledWidth = this.canvas.width;\n      this.preScaledHeight = this.canvas.height;\n\n      this.canvas.width = this.preScaledWidth * ratio;\n      this.canvas.height = this.preScaledHeight * ratio;\n      this.canvas.style.width = `${this.preScaledWidth}px`;\n      this.canvas.style.height = `${this.preScaledHeight}px`;\n\n      this.context.scale(ratio, ratio);\n\n      this.width = (this.originalWidth = this.canvas.width);\n      return this.height = (this.originalHeight = this.canvas.height);\n    }\n  }\n\n  // Calculate the HiDPI ratio of this display based on the backing store\n  // and the pixel ratio.\n  // @return [Number] The HiDPI pixel ratio.\n  hiDPIRatio() {\n    const devicePixelRatio = window.devicePixelRatio || 1;\n    const backingStoreRatio = this.context.webkitBackingStorePixelRatio ||\n      this.context.mozBackingStorePixelRatio ||\n      this.context.msBackingStorePixelRatio ||\n      this.context.oBackingStorePixelRatio ||\n      this.context.backingStorePixelRatio || 1;\n\n    return devicePixelRatio / backingStoreRatio;\n  }\n\n  // Is this display HiDPI capable?\n  // @return [Boolean]\n  hiDPICapable() { return (window.devicePixelRatio != null) && (window.devicePixelRatio !== 1); }\n\n  // Do we need to perform an image swap with a HiDPI image?\n  // @return [Boolean]\n  needsHiDPISwap() {\n    if (this.hiDPIDisabled() || !this.hiDPICapable()) { return false; }\n    return this.hiDPIReplacement() !== null;\n  }\n\n  // Gets the HiDPI replacement for the initialization image.\n  // @return [String] URL to the HiDPI version.\n  hiDPIReplacement() {\n    if (this.image == null) { return null; }\n    return this.image.getAttribute('data-caman-hidpi');\n  }\n\n  // Replaces the current canvas with a new one, and properly updates all of the\n  // applicable references for this instance.\n  //\n  // @param [DOMObject] newCanvas The canvas to swap into this instance.\n  replaceCanvas(newCanvas) {\n    const oldCanvas = this.canvas;\n    this.canvas = newCanvas;\n    this.context = this.canvas.getContext('2d');\n\n    oldCanvas.parentNode.replaceChild(this.canvas, oldCanvas);\n\n    this.width  = this.canvas.width;\n    this.height = this.canvas.height;\n\n    this.reloadCanvasData();\n\n    return this.dimensions = {\n      width: this.canvas.width,\n      height: this.canvas.height\n    };\n  }\n\n  // Begins the rendering process. This will execute all of the filter functions\n  // called either since initialization or the previous render.\n  //\n  // @param [Function] callback Function to call when rendering is finished.\n  render(callback) {\n    if (callback == null) { callback = function() {}; }\n    Caman.Event.trigger(this, \"renderStart\");\n\n    return this.renderer.execute(() => {\n      this.context.putImageData(this.imageData, 0, 0);\n      return callback.call(this);\n    });\n  }\n\n  // Reverts the canvas back to it's original state while\n  // maintaining any cropped or resized dimensions.\n  //\n  // @param [Boolean] updateContext Should we apply the reverted pixel data to the\n  //   canvas context thus triggering a re-render by the browser?\n  revert(updateContext) {\n    if (updateContext == null) { updateContext = true; }\n    if (!Caman.allowRevert) { throw \"Revert disabled\"; }\n\n    const iterable = this.originalVisiblePixels();\n    for (let i = 0; i < iterable.length; i++) { const pixel = iterable[i]; this.pixelData[i] = pixel; }\n    if (updateContext) { return this.context.putImageData(this.imageData, 0, 0); }\n  }\n\n  // Completely resets the canvas back to it's original state.\n  // Any size adjustments will also be reset.\n  reset() {\n    const canvas = document.createElement('canvas');\n    Util.copyAttributes(this.canvas, canvas);\n\n    canvas.width = this.originalWidth;\n    canvas.height = this.originalHeight;\n\n    const ctx = canvas.getContext('2d');\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const pixelData = imageData.data;\n\n    for (let i = 0; i < this.initializedPixelData.length; i++) { const pixel = this.initializedPixelData[i]; pixelData[i] = pixel; }\n\n    ctx.putImageData(imageData, 0, 0);\n\n    this.cropCoordinates = {x: 0, y: 0};\n    this.resized = false;\n\n    this.angle = 0;\n    this.rotated = false;\n\n    return this.replaceCanvas(canvas);\n  }\n\n  // Returns the original pixel data while maintaining any\n  // cropping or resizing that may have occured.\n  // **Warning**: this is currently in beta status.\n  //\n  // @return [Array] Original pixel values still visible after cropping or resizing.\n  originalVisiblePixels() {\n    let i, pixelData, width;\n    let end;\n    if (!Caman.allowRevert) { throw \"Revert disabled\"; }\n\n    const pixels = [];\n\n    const startX = this.cropCoordinates.x;\n    const endX = startX + this.width;\n    const startY = this.cropCoordinates.y;\n    const endY = startY + this.height;\n\n    if (this.resized) {\n      const canvas = document.createElement('canvas');\n      canvas.width = this.originalWidth;\n      canvas.height = this.originalHeight;\n\n      let ctx = canvas.getContext('2d');\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      pixelData = imageData.data;\n\n      for (i = 0; i < this.originalPixelData.length; i++) { const pixel = this.originalPixelData[i]; pixelData[i] = pixel; }\n\n      ctx.putImageData(imageData, 0, 0);\n\n      const scaledCanvas = document.createElement('canvas');\n      scaledCanvas.width = this.width;\n      scaledCanvas.height = this.height;\n\n      ctx = scaledCanvas.getContext('2d');\n      ctx.drawImage(canvas, 0, 0, this.originalWidth, this.originalHeight, 0, 0, this.width, this.height);\n\n      pixelData = ctx.getImageData(0, 0, this.width, this.height).data;\n      ({ width } = this);\n    } else if (this.rotated) {\n      var canvas = document.createElement('canvas');//Canvas for initial state\n\n      canvas.width = this.originalWidth; //give it the original width\n      canvas.height = this.originalHeight; //and original height\n\n      var ctx = canvas.getContext('2d');\n      var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      pixelData = imageData.data;//get the pixelData (length equal to those of initial canvas\n      var _ref = this.originalPixelData; //use it as a reference array\n\n      let i, _i, _len, pixel;\n\n      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n        pixel = _ref[i];\n        pixelData[i] = pixel; //give pixelData the initial pixels\n      }\n      ctx.putImageData(imageData, 0, 0); //put it back on our canvas\n      var rotatedCanvas = document.createElement('canvas'); //canvas to rotate from initial\n      var rotatedCtx = rotatedCanvas.getContext('2d');\n      rotatedCanvas.width = this.canvas.width;//Our canvas was already rotated so it has been replaced. Caman's canvas attribute is allready rotated, So use that width\n      rotatedCanvas.height = this.canvas.height; //the same\n      var x = rotatedCanvas.width / 2; //for translating\n      var y = rotatedCanvas.height / 2; //same\n      rotatedCtx.save();\n      rotatedCtx.translate(x, y);\n      rotatedCtx.rotate(this.angle * Math.PI / 180); //rotation based on the total angle\n      rotatedCtx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height); //put the image back on canvas\n      rotatedCtx.restore(); //restore it\n      pixelData = rotatedCtx.getImageData(0, 0, rotatedCanvas.width, rotatedCanvas.height).data; //get the pixelData back\n      width = rotatedCanvas.width; //used for returning the pixels in revert function\n    } else {\n      pixelData = this.originalPixelData;\n      width = this.originalWidth;\n    }\n\n    for (i = 0, end = pixelData.length; i < end; i += 4) {\n      const coord = Caman.Pixel.locationToCoordinates(i, width);\n      if ((startX <= coord.x && coord.x < endX) && (startY <= coord.y && coord.y < endY)) {\n        pixels.push(pixelData[i],\n          pixelData[i+1],\n          pixelData[i+2],\n          pixelData[i+3]);\n      }\n    }\n\n    return pixels;\n  }\n\n  // Pushes the filter callback that modifies the RGBA object into the\n  // render queue.\n  //\n  // @param [String] name Name of the filter function.\n  // @param [Function] processFn The Filter function.\n  // @return [Caman]\n  process(name, processFn) {\n    this.renderer.add({\n      type: Caman.Filter.Type.Single,\n      name,\n      processFn\n    });\n\n    return this;\n  }\n\n  // Pushes the kernel into the render queue.\n  //\n  // @param [String] name The name of the kernel.\n  // @param [Array] adjust The convolution kernel represented as a 1D array.\n  // @param [Number] divisor The divisor for the convolution.\n  // @param [Number] bias The bias for the convolution.\n  // @return [Caman]\n  processKernel(name, adjust, divisor = null, bias) {\n    if (bias == null) { bias = 0; }\n    if (divisor == null) {\n      divisor = 0;\n      for (let i = 0, end = adjust.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) { divisor += adjust[i]; }\n    }\n\n    this.renderer.add({\n      type: Caman.Filter.Type.Kernel,\n      name,\n      adjust,\n      divisor,\n      bias\n    });\n\n    return this;\n  }\n\n  // Adds a standalone plugin into the render queue.\n  //\n  // @param [String] plugin Name of the plugin.\n  // @param [Array] args Array of arguments to pass to the plugin.\n  // @return [Caman]\n  processPlugin(plugin, args) {\n    this.renderer.add({\n      type: Caman.Filter.Type.Plugin,\n      plugin,\n      args\n    });\n\n    return this;\n  }\n\n  // Pushes a new layer operation into the render queue and calls the layer\n  // callback.\n  //\n  // @param [Function] callback Function that is executed within the context of the layer.\n  //   All filter and adjustment functions for the layer will be executed inside of this function.\n  // @return [Caman]\n  newLayer(callback) {\n    const layer = new Caman.Layer(this);\n    this.canvasQueue.push(layer);\n    this.renderer.add({type: Caman.Filter.Type.LayerDequeue});\n\n    callback.call(layer);\n\n    this.renderer.add({type: Caman.Filter.Type.LayerFinished});\n    return this;\n  }\n\n  // Pushes the layer context and moves to the next operation.\n  // @param [Layer] layer The layer to execute.\n  executeLayer(layer) { return this.pushContext(layer); }\n\n  // Set all of the relevant data to the new layer.\n  // @param [Layer] layer The layer whose context we want to switch to.\n  pushContext(layer) {\n    this.layerStack.push(this.currentLayer);\n    this.pixelStack.push(this.pixelData);\n    this.currentLayer = layer;\n    return this.pixelData = layer.pixelData;\n  }\n\n  // Restore the previous layer context.\n  popContext() {\n    this.pixelData = this.pixelStack.pop();\n    return this.currentLayer = this.layerStack.pop();\n  }\n\n  // Applies the current layer to its parent layer.\n  applyCurrentLayer() { return this.currentLayer.applyToParent(); }\n\n  save() {\n    return this.browserSave.apply(this, arguments);\n  };\n\n  browserSave(type) {\n    if (type == null) { type = \"png\"; }\n    type = type.toLowerCase();\n\n    // Force download (its a bit hackish)\n    const image = this.toBase64(type).replace(`image/${type}`, \"image/octet-stream\");\n    return document.location.href = image;\n  };\n\n  // Takes the current canvas data, converts it to Base64, then sets it as the source\n  // of a new Image object and returns it.\n  toImage(type) {\n    const img = new Image();\n    img.src = this.toBase64(type);\n    img.width = this.dimensions.width;\n    img.height = this.dimensions.height;\n\n    if (window.devicePixelRatio) {\n      img.width /= window.devicePixelRatio;\n      img.height /= window.devicePixelRatio;\n    }\n\n    return img;\n  };\n\n  // Base64 encodes the current canvas\n  toBase64(type) {\n    if (type == null) { type = \"png\"; }\n    type = type.toLowerCase();\n    return this.canvas.toDataURL(`image/${type}`);\n  };\n}\n\nCaman.initClass();\n\nwindow.Caman = Caman;\n\nexport default Caman;\n","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\logger.js",["602"],"function Logger() {\n  let name, _i, _len, _ref;\n  _ref = ['log', 'info', 'warn', 'error'];\n  for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n    name = _ref[_i];\n    this[name] = (function (name) {\n      return function () {\n        let args, e;\n        args = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];\n        if (!Caman.DEBUG) {\n          return;\n        }\n        try {\n          return console[name].apply(console, args);\n        } catch (_error) {\n          e = _error;\n          return console[name](args);\n        }\n      };\n    })(name);\n  }\n  this.debug = this.log;\n}\n\nconst Log = new Logger();\n\nexport { Log };","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\blander.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\util.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\canvas-round.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\utils\\map-number-range.js",["603"],"export  default Number.prototype.mapNumber = function (in_min, in_max, out_min, out_max) {\n  return (this - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Effect.js",["604"],"import React, { Component } from 'react';\nimport { EffectWrapper, EffectIcon, EffectLabel} from '../../styledComponents';\nimport { getLabel, getIcon } from '../../utils';\n\n\nexport default class extends Component {\n\n\n  render() {\n    const { active, name, onApplyEffects, noCapitalStrs } = this.props;\n\n    return (\n      <EffectWrapper active={active === name} onClick={onApplyEffects.bind(null, name)}>\n        <EffectIcon src={getIcon(name)}/>\n        <EffectLabel noCapitalStrs={noCapitalStrs}>{getLabel(name)}</EffectLabel>\n      </EffectWrapper>\n    )\n  }\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Toolbar\\Filter.js",["605"],"import React, { Component } from 'react';\nimport { EffectWrapper, EffectIcon, EffectLabel} from '../../styledComponents';\nimport { getIcon, getLabel } from '../../utils';\n\n\nexport default class extends Component {\n\n\n  render() {\n    const { active, name, onApplyFilters } = this.props;\n\n    return (\n      <EffectWrapper active={active === name} onClick={onApplyFilters.bind(null, name)}>\n        <EffectIcon src={getIcon(name)}/>\n        <EffectLabel>{getLabel(name)}</EffectLabel>\n      </EffectWrapper>\n    )\n  }\n}","D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Range.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\styledComponents\\Shapes.ui.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\components\\Shared\\Select.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\module.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\store.js",[],"D:\\@@@jhs\\@@@@@@NEW\\slazzer-image-editor\\src\\lib\\caman\\core\\renderer.js",["606"],"import { Util } from './util';\nimport { Log } from './logger';\n\n/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS202: Simplify dynamic range loops\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS206: Consider reworking classes to avoid initClass\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n// Handles all of the various rendering methods in Caman. Most of the image modification happens\n// here. A new Renderer object is created for every render operation.\nclass Renderer {\n  static initClass() {\n    // The number of blocks to split the image into during the render process to simulate\n    // concurrency. This also helps the browser manage the (possibly) long running render jobs.\n    this.Blocks = 4;\n  }\n\n  constructor(c) {\n    this.processNext = this.processNext.bind(this);\n    this.c = c;\n    this.renderQueue = [];\n    this.modPixelData = null;\n  }\n\n  add(job) {\n    if (job == null) { return; }\n    return this.renderQueue.push(job);\n  }\n\n  // Grabs the next operation from the render queue and passes it to Renderer\n  // for execution\n  processNext() {\n    // If the queue is empty, fire the finished callback\n    if (this.renderQueue.length === 0) {\n      Caman.Event.trigger(this, \"renderFinished\");\n      if (this.finishedFn != null) { this.finishedFn.call(this.c); }\n\n      return this;\n    }\n\n    this.currentJob = this.renderQueue.shift();\n\n    switch (this.currentJob.type) {\n      case Caman.Filter.Type.LayerDequeue:\n        var layer = this.c.canvasQueue.shift();\n        this.c.executeLayer(layer);\n        return this.processNext();\n      case Caman.Filter.Type.LayerFinished:\n        this.c.applyCurrentLayer();\n        this.c.popContext();\n        return this.processNext();\n      case Caman.Filter.Type.LoadOverlay:\n        return this.loadOverlay(this.currentJob.layer, this.currentJob.src);\n      case Caman.Filter.Type.LoadLayerMask:\n        return this.loadLayerMask(this.currentJob.layer, this.currentJob.src);\n      case Caman.Filter.Type.Plugin:\n        return this.executePlugin();\n      default:\n        return this.executeFilter();\n    }\n  }\n\n  execute(callback) {\n    this.finishedFn = callback;\n    this.modPixelData = Util.dataArray(this.c.pixelData.length);\n\n    return this.processNext();\n  }\n\n  eachBlock(fn) {\n    // Prepare all the required render data\n    this.blocksDone = 0;\n\n    const n = this.c.pixelData.length;\n    const blockPixelLength = Math.floor((n / 4) / Renderer.Blocks);\n    const blockN = blockPixelLength * 4;\n    const lastBlockN = blockN + (((n / 4) % Renderer.Blocks) * 4);\n\n    return (() => {\n      const result = [];\n      for (var i = 0, end1 = Renderer.Blocks, asc = 0 <= end1; asc ? i < end1 : i > end1; asc ? i++ : i--) {\n        var start = i * blockN;\n        var end = start + (i === (Renderer.Blocks - 1) ? lastBlockN : blockN);\n\n        if (Caman.NodeJS) {\n          const f = Fiber(() => fn.call(this, i, start, end));\n          const bnum = f.run();\n          result.push(this.blockFinished(bnum));\n        } else {\n          result.push(setTimeout(((i, start, end) => {\n              return () => fn.call(this, i, start, end);\n            })(i, start, end)\n            , 0));\n        }\n      }\n      return result;\n    })();\n  }\n\n  // The core of the image rendering, this function executes the provided filter.\n  //\n  // NOTE: this does not write the updated pixel data to the canvas. That happens when all filters\n  // are finished rendering in order to be as fast as possible.\n  executeFilter() {\n    Caman.Event.trigger(this.c, \"processStart\", this.currentJob);\n\n    if (this.currentJob.type === Caman.Filter.Type.Single) {\n      return this.eachBlock(this.renderBlock);\n    } else {\n      return this.eachBlock(this.renderKernel);\n    }\n  }\n\n  // Executes a standalone plugin\n  executePlugin() {\n    Log.debug(`Executing plugin ${this.currentJob.plugin}`);\n    Caman.Plugin.execute(this.c, this.currentJob.plugin, this.currentJob.args);\n    Log.debug(`Plugin ${this.currentJob.plugin} finished!`);\n\n    return this.processNext();\n  }\n\n  // Renders a single block of the canvas with the current filter function\n  renderBlock(bnum, start, end) {\n    Log.debug(`Block #${bnum} - Filter: ${this.currentJob.name}, Start: ${start}, End: ${end}`);\n    Caman.Event.trigger(this.c, \"blockStarted\", {\n        blockNum: bnum,\n        totalBlocks: Renderer.Blocks,\n        startPixel: start,\n        endPixel: end\n      }\n    );\n\n    const pixel = new Caman.Pixel();\n    pixel.setContext(this.c);\n\n    for (let i = start, end1 = end; i < end1; i += 4) {\n      pixel.loc = i;\n\n      pixel.r = this.c.pixelData[i];\n      pixel.g = this.c.pixelData[i+1];\n      pixel.b = this.c.pixelData[i+2];\n      pixel.a = this.c.pixelData[i+3];\n\n      this.currentJob.processFn(pixel);\n\n      this.c.pixelData[i]   = Util.clampRGB(pixel.r);\n      this.c.pixelData[i+1] = Util.clampRGB(pixel.g);\n      this.c.pixelData[i+2] = Util.clampRGB(pixel.b);\n      this.c.pixelData[i+3] = Util.clampRGB(pixel.a);\n    }\n\n    return this.blockFinished(bnum);\n  }\n\n  // Applies an image kernel to the canvas\n  renderKernel(bnum, start, end) {\n    const { name } = this.currentJob;\n    const { bias } = this.currentJob;\n    const { divisor } = this.currentJob;\n    const n = this.c.pixelData.length;\n\n    const { adjust } = this.currentJob;\n    const adjustSize = Math.sqrt(adjust.length);\n\n    const kernel = [];\n\n    Log.debug(`Rendering kernel - Filter: ${this.currentJob.name}`);\n\n    start = Math.max(start, this.c.dimensions.width * 4 * ((adjustSize - 1) / 2));\n    end = Math.min(end, n - (this.c.dimensions.width * 4 * ((adjustSize - 1) / 2)));\n\n    const builder = (adjustSize - 1) / 2;\n\n    const pixel = new Caman.Pixel();\n    pixel.setContext(this.c);\n\n    for (let i = start, end1 = end; i < end1; i += 4) {\n      pixel.loc = i;\n      let builderIndex = 0;\n\n      for (let j = -builder, end2 = builder, asc = -builder <= end2; asc ? j <= end2 : j >= end2; asc ? j++ : j--) {\n        for (let k = builder, end3 = -builder, asc1 = builder <= end3; asc1 ? k <= end3 : k >= end3; asc1 ? k++ : k--) {\n          const p = pixel.getPixelRelative(j, k);\n          kernel[builderIndex * 3]     = p.r;\n          kernel[(builderIndex * 3) + 1] = p.g;\n          kernel[(builderIndex * 3) + 2] = p.b;\n\n          builderIndex++;\n        }\n      }\n\n      const res = this.processKernel(adjust, kernel, divisor, bias);\n\n      this.modPixelData[i]    = Util.clampRGB(res.r);\n      this.modPixelData[i+1]  = Util.clampRGB(res.g);\n      this.modPixelData[i+2]  = Util.clampRGB(res.b);\n      this.modPixelData[i+3]  = this.c.pixelData[i+3];\n    }\n\n    return this.blockFinished(bnum);\n  }\n\n  // Called when a single block is finished rendering. Once all blocks are done, we signal that this\n  // filter is finished rendering and continue to the next step.\n  blockFinished(bnum) {\n    if (bnum >= 0) { Log.debug(`Block #${bnum} finished! Filter: ${this.currentJob.name}`); }\n    this.blocksDone++;\n\n    Caman.Event.trigger(this.c, \"blockFinished\", {\n        blockNum: bnum,\n        blocksFinished: this.blocksDone,\n        totalBlocks: Renderer.Blocks\n      }\n    );\n\n    if (this.blocksDone === Renderer.Blocks) {\n      if (this.currentJob.type === Caman.Filter.Type.Kernel) {\n        for (let i = 0, end = this.c.pixelData.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n          this.c.pixelData[i] = this.modPixelData[i];\n        }\n      }\n\n      if (bnum >=0) { Log.debug(`Filter ${this.currentJob.name} finished!`); }\n      Caman.Event.trigger(this.c, \"processComplete\", this.currentJob);\n\n      return this.processNext();\n    }\n  }\n\n  // The \"filter function\" for kernel adjustments.\n  processKernel(adjust, kernel, divisor, bias) {\n    const val = {r: 0, g: 0, b: 0};\n\n    for (let i = 0, end = adjust.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n      val.r += adjust[i] * kernel[i * 3];\n      val.g += adjust[i] * kernel[(i * 3) + 1];\n      val.b += adjust[i] * kernel[(i * 3) + 2];\n    }\n\n    val.r = (val.r / divisor) + bias;\n    val.g = (val.g / divisor) + bias;\n    val.b = (val.b / divisor) + bias;\n    return val;\n  }\n\n  // Loads an image onto the current canvas\n  loadOverlay(layer, src) {\n    const img = new Image();\n    img.onload = () => {\n      layer.context.drawImage(img, 0, 0, this.c.dimensions.width, this.c.dimensions.height);\n      layer.imageData = layer.context.getImageData(0, 0, this.c.dimensions.width, this.c.dimensions.height);\n      layer.pixelData = layer.imageData.data;\n\n      this.c.pixelData = layer.pixelData;\n\n      return this.processNext();\n    };\n\n    const proxyUrl = Caman.IO.remoteCheck(src);\n    return img.src = (proxyUrl != null) ? proxyUrl : src;\n  }\n\n  // Loads an image and save as mask data\n  loadLayerMask(layer, src) {\n    const img = new Image();\n    img.onload = () => {\n      const canvas = document.createElement('canvas');\n      canvas.width = this.c.dimensions.width;\n      canvas.height = this.c.dimensions.height;\n      const context = canvas.getContext('2d');\n      context.drawImage(img, 0, 0, this.c.dimensions.width, this.c.dimensions.height);\n      const maskData = context.getImageData(0, 0, this.c.dimensions.width, this.c.dimensions.height);\n      layer.maskData = maskData.data;\n\n      return this.processNext();\n    };\n\n    const proxyUrl = Caman.IO.remoteCheck(src);\n    return img.src = (proxyUrl != null) ? proxyUrl : src;\n  }\n}\n\nRenderer.initClass();\n\nexport default Renderer;\n",{"ruleId":"607","severity":1,"message":"608","line":14,"column":7,"nodeType":"609","endLine":14,"endColumn":105},{"ruleId":"610","replacedBy":"611"},{"ruleId":"612","replacedBy":"613"},{"ruleId":"614","severity":1,"message":"615","line":28,"column":1,"nodeType":"616","endLine":510,"endColumn":2},{"ruleId":"617","severity":1,"message":"618","line":339,"column":5,"nodeType":"619","messageId":"620","endLine":351,"endColumn":6},{"ruleId":"614","severity":1,"message":"621","line":1,"column":1,"nodeType":"616","endLine":18,"endColumn":3},{"ruleId":"614","severity":1,"message":"621","line":1,"column":1,"nodeType":"616","endLine":18,"endColumn":3},{"ruleId":"614","severity":1,"message":"621","line":5,"column":1,"nodeType":"616","endLine":9,"endColumn":2},{"ruleId":"622","severity":1,"message":"623","line":281,"column":70,"nodeType":"624","messageId":"625","endLine":281,"endColumn":72},{"ruleId":"622","severity":1,"message":"623","line":281,"column":84,"nodeType":"624","messageId":"625","endLine":281,"endColumn":86},{"ruleId":"626","severity":1,"message":"627","line":283,"column":24,"nodeType":"628","messageId":"629","endLine":283,"endColumn":36},{"ruleId":"622","severity":1,"message":"630","line":290,"column":11,"nodeType":"624","messageId":"625","endLine":290,"endColumn":13},{"ruleId":"622","severity":1,"message":"630","line":290,"column":17,"nodeType":"624","messageId":"625","endLine":290,"endColumn":19},{"ruleId":"631","severity":1,"message":"632","line":293,"column":41,"nodeType":"624","messageId":"633","endLine":293,"endColumn":43},{"ruleId":"631","severity":1,"message":"632","line":293,"column":47,"nodeType":"624","messageId":"633","endLine":293,"endColumn":48},{"ruleId":"631","severity":1,"message":"632","line":293,"column":65,"nodeType":"624","messageId":"633","endLine":293,"endColumn":67},{"ruleId":"631","severity":1,"message":"632","line":293,"column":70,"nodeType":"624","messageId":"633","endLine":293,"endColumn":71},{"ruleId":"622","severity":1,"message":"630","line":293,"column":102,"nodeType":"624","messageId":"625","endLine":293,"endColumn":104},{"ruleId":"622","severity":1,"message":"630","line":293,"column":108,"nodeType":"624","messageId":"625","endLine":293,"endColumn":110},{"ruleId":"631","severity":1,"message":"632","line":293,"column":117,"nodeType":"624","messageId":"633","endLine":293,"endColumn":119},{"ruleId":"631","severity":1,"message":"632","line":293,"column":121,"nodeType":"624","messageId":"633","endLine":293,"endColumn":122},{"ruleId":"634","severity":1,"message":"635","line":296,"column":47,"nodeType":"636","messageId":"637","endLine":296,"endColumn":48},{"ruleId":"622","severity":1,"message":"630","line":296,"column":89,"nodeType":"624","messageId":"625","endLine":296,"endColumn":91},{"ruleId":"634","severity":1,"message":"638","line":296,"column":112,"nodeType":"636","messageId":"637","endLine":296,"endColumn":113},{"ruleId":"634","severity":1,"message":"639","line":296,"column":123,"nodeType":"636","messageId":"637","endLine":296,"endColumn":125},{"ruleId":"622","severity":1,"message":"623","line":296,"column":132,"nodeType":"624","messageId":"625","endLine":296,"endColumn":134},{"ruleId":"640","severity":1,"message":"641","line":139,"column":54,"nodeType":"609","endLine":139,"endColumn":71},{"ruleId":"614","severity":1,"message":"621","line":1,"column":1,"nodeType":"616","endLine":51,"endColumn":3},{"ruleId":"614","severity":1,"message":"621","line":1,"column":1,"nodeType":"616","endLine":51,"endColumn":3},{"ruleId":"614","severity":1,"message":"621","line":1,"column":1,"nodeType":"616","endLine":50,"endColumn":3},{"ruleId":"614","severity":1,"message":"615","line":6,"column":1,"nodeType":"616","endLine":62,"endColumn":2},{"ruleId":"614","severity":1,"message":"615","line":8,"column":1,"nodeType":"616","endLine":54,"endColumn":2},{"ruleId":"631","severity":1,"message":"642","line":18,"column":31,"nodeType":"643","messageId":"633","endLine":18,"endColumn":33},{"ruleId":"631","severity":1,"message":"642","line":18,"column":65,"nodeType":"643","messageId":"633","endLine":18,"endColumn":67},{"ruleId":"614","severity":1,"message":"615","line":17,"column":1,"nodeType":"616","endLine":41,"endColumn":2},{"ruleId":"614","severity":1,"message":"615","line":19,"column":1,"nodeType":"616","endLine":127,"endColumn":2},{"ruleId":"614","severity":1,"message":"615","line":5,"column":1,"nodeType":"616","endLine":20,"endColumn":2},{"ruleId":"614","severity":1,"message":"615","line":9,"column":1,"nodeType":"616","endLine":57,"endColumn":2},{"ruleId":"644","severity":1,"message":"645","line":39,"column":16,"nodeType":"646","messageId":"647","endLine":39,"endColumn":18},{"ruleId":"617","severity":1,"message":"618","line":62,"column":20,"nodeType":"619","messageId":"620","endLine":66,"endColumn":8},{"ruleId":"617","severity":1,"message":"618","line":153,"column":20,"nodeType":"619","messageId":"620","endLine":157,"endColumn":8},{"ruleId":"617","severity":1,"message":"618","line":182,"column":5,"nodeType":"619","messageId":"620","endLine":189,"endColumn":6},{"ruleId":"648","severity":1,"message":"649","line":73,"column":7,"nodeType":"650","messageId":"651","endLine":73,"endColumn":53},{"ruleId":"648","severity":1,"message":"649","line":128,"column":7,"nodeType":"650","messageId":"651","endLine":128,"endColumn":54},{"ruleId":"652","severity":1,"message":"653","line":133,"column":11,"nodeType":"636","messageId":"654","endLine":133,"endColumn":15},{"ruleId":"652","severity":1,"message":"655","line":170,"column":9,"nodeType":"636","messageId":"654","endLine":170,"endColumn":14},{"ruleId":"648","severity":1,"message":"649","line":40,"column":27,"nodeType":"650","messageId":"651","endLine":40,"endColumn":62},{"ruleId":"648","severity":1,"message":"649","line":49,"column":27,"nodeType":"650","messageId":"651","endLine":49,"endColumn":62},{"ruleId":"648","severity":1,"message":"649","line":63,"column":27,"nodeType":"650","messageId":"651","endLine":63,"endColumn":62},{"ruleId":"648","severity":1,"message":"649","line":79,"column":27,"nodeType":"650","messageId":"651","endLine":79,"endColumn":62},{"ruleId":"648","severity":1,"message":"649","line":95,"column":27,"nodeType":"650","messageId":"651","endLine":95,"endColumn":62},{"ruleId":"648","severity":1,"message":"649","line":103,"column":27,"nodeType":"650","messageId":"651","endLine":103,"endColumn":62},{"ruleId":"652","severity":1,"message":"656","line":106,"column":9,"nodeType":"636","messageId":"654","endLine":106,"endColumn":10},{"ruleId":"652","severity":1,"message":"657","line":106,"column":12,"nodeType":"636","messageId":"654","endLine":106,"endColumn":13},{"ruleId":"652","severity":1,"message":"658","line":106,"column":23,"nodeType":"636","messageId":"654","endLine":106,"endColumn":24},{"ruleId":"648","severity":1,"message":"649","line":271,"column":5,"nodeType":"650","messageId":"651","endLine":271,"endColumn":58},{"ruleId":"652","severity":1,"message":"659","line":65,"column":3,"nodeType":"636","messageId":"654","endLine":65,"endColumn":5},{"ruleId":"652","severity":1,"message":"659","line":139,"column":13,"nodeType":"636","messageId":"654","endLine":139,"endColumn":15},{"ruleId":"644","severity":1,"message":"660","line":115,"column":24,"nodeType":"646","messageId":"661","endLine":115,"endColumn":26},{"ruleId":"662","severity":1,"message":"663","line":486,"column":7,"nodeType":"664","messageId":"665","endLine":487,"endColumn":16},{"ruleId":"662","severity":1,"message":"663","line":689,"column":7,"nodeType":"664","messageId":"665","endLine":690,"endColumn":16},{"ruleId":"666","severity":1,"message":"667","line":847,"column":47,"nodeType":"668","messageId":"669","endLine":847,"endColumn":80},{"ruleId":"652","severity":1,"message":"670","line":429,"column":11,"nodeType":"636","messageId":"654","endLine":429,"endColumn":25},{"ruleId":"652","severity":1,"message":"671","line":1177,"column":26,"nodeType":"636","messageId":"654","endLine":1177,"endColumn":34},{"ruleId":"652","severity":1,"message":"672","line":1177,"column":44,"nodeType":"636","messageId":"654","endLine":1177,"endColumn":53},{"ruleId":"614","severity":1,"message":"615","line":7,"column":1,"nodeType":"616","endLine":17,"endColumn":2},{"ruleId":"614","severity":1,"message":"615","line":6,"column":1,"nodeType":"616","endLine":117,"endColumn":2},{"ruleId":"614","severity":1,"message":"615","line":7,"column":1,"nodeType":"616","endLine":25,"endColumn":2},{"ruleId":"614","severity":1,"message":"615","line":9,"column":1,"nodeType":"616","endLine":118,"endColumn":2},{"ruleId":"614","severity":1,"message":"615","line":16,"column":1,"nodeType":"616","endLine":103,"endColumn":2},{"ruleId":"614","severity":1,"message":"615","line":6,"column":1,"nodeType":"616","endLine":52,"endColumn":2},{"ruleId":"614","severity":1,"message":"615","line":29,"column":1,"nodeType":"616","endLine":503,"endColumn":2},{"ruleId":"652","severity":1,"message":"673","line":337,"column":7,"nodeType":"636","messageId":"654","endLine":337,"endColumn":21},{"ruleId":"614","severity":1,"message":"615","line":5,"column":1,"nodeType":"616","endLine":58,"endColumn":2},{"ruleId":"674","severity":1,"message":"675","line":121,"column":7,"nodeType":"676","messageId":"625","endLine":121,"endColumn":11},{"ruleId":"648","severity":1,"message":"649","line":123,"column":35,"nodeType":"650","messageId":"651","endLine":123,"endColumn":61},{"ruleId":"677","severity":1,"message":"678","line":125,"column":9,"nodeType":"679","messageId":"680","endLine":125,"endColumn":13},{"ruleId":"677","severity":1,"message":"678","line":131,"column":7,"nodeType":"679","messageId":"680","endLine":131,"endColumn":11},{"ruleId":"677","severity":1,"message":"678","line":131,"column":25,"nodeType":"679","messageId":"680","endLine":131,"endColumn":29},{"ruleId":"677","severity":1,"message":"678","line":131,"column":46,"nodeType":"679","messageId":"680","endLine":131,"endColumn":50},{"ruleId":"677","severity":1,"message":"678","line":132,"column":7,"nodeType":"679","messageId":"680","endLine":132,"endColumn":11},{"ruleId":"677","severity":1,"message":"678","line":132,"column":26,"nodeType":"679","messageId":"680","endLine":132,"endColumn":30},{"ruleId":"677","severity":1,"message":"678","line":132,"column":48,"nodeType":"679","messageId":"680","endLine":132,"endColumn":52},{"ruleId":"677","severity":1,"message":"678","line":150,"column":7,"nodeType":"679","messageId":"680","endLine":150,"endColumn":11},{"ruleId":"677","severity":1,"message":"678","line":152,"column":7,"nodeType":"679","messageId":"680","endLine":152,"endColumn":11},{"ruleId":"677","severity":1,"message":"678","line":152,"column":36,"nodeType":"679","messageId":"680","endLine":152,"endColumn":40},{"ruleId":"677","severity":1,"message":"678","line":153,"column":7,"nodeType":"679","messageId":"680","endLine":153,"endColumn":11},{"ruleId":"677","severity":1,"message":"678","line":154,"column":7,"nodeType":"679","messageId":"680","endLine":154,"endColumn":11},{"ruleId":"677","severity":1,"message":"678","line":155,"column":7,"nodeType":"679","messageId":"680","endLine":155,"endColumn":11},{"ruleId":"677","severity":1,"message":"678","line":157,"column":7,"nodeType":"679","messageId":"680","endLine":157,"endColumn":11},{"ruleId":"677","severity":1,"message":"678","line":158,"column":7,"nodeType":"679","messageId":"680","endLine":158,"endColumn":11},{"ruleId":"677","severity":1,"message":"678","line":159,"column":7,"nodeType":"679","messageId":"680","endLine":159,"endColumn":11},{"ruleId":"677","severity":1,"message":"678","line":160,"column":7,"nodeType":"679","messageId":"680","endLine":160,"endColumn":11},{"ruleId":"677","severity":1,"message":"678","line":161,"column":7,"nodeType":"679","messageId":"680","endLine":161,"endColumn":11},{"ruleId":"677","severity":1,"message":"678","line":164,"column":7,"nodeType":"679","messageId":"680","endLine":164,"endColumn":11},{"ruleId":"677","severity":1,"message":"678","line":164,"column":36,"nodeType":"679","messageId":"680","endLine":164,"endColumn":40},{"ruleId":"677","severity":1,"message":"678","line":166,"column":7,"nodeType":"679","messageId":"680","endLine":166,"endColumn":11},{"ruleId":"677","severity":1,"message":"678","line":171,"column":14,"nodeType":"679","messageId":"680","endLine":171,"endColumn":18},{"ruleId":"648","severity":1,"message":"649","line":206,"column":30,"nodeType":"650","messageId":"651","endLine":206,"endColumn":62},{"ruleId":"617","severity":1,"message":"618","line":218,"column":5,"nodeType":"619","messageId":"620","endLine":221,"endColumn":6},{"ruleId":"648","severity":1,"message":"649","line":249,"column":33,"nodeType":"650","messageId":"651","endLine":249,"endColumn":92},{"ruleId":"617","severity":1,"message":"618","line":257,"column":5,"nodeType":"619","messageId":"620","endLine":261,"endColumn":6},{"ruleId":"648","severity":1,"message":"649","line":413,"column":31,"nodeType":"650","messageId":"651","endLine":413,"endColumn":55},{"ruleId":"648","severity":1,"message":"649","line":536,"column":31,"nodeType":"650","messageId":"651","endLine":536,"endColumn":55},{"ruleId":"648","severity":1,"message":"649","line":577,"column":31,"nodeType":"650","messageId":"651","endLine":577,"endColumn":55},{"ruleId":"652","severity":1,"message":"681","line":18,"column":11,"nodeType":"636","messageId":"654","endLine":18,"endColumn":12},{"ruleId":"682","severity":1,"message":"683","line":1,"column":17,"nodeType":"684","messageId":"625","endLine":3,"endColumn":2},{"ruleId":"614","severity":1,"message":"615","line":6,"column":1,"nodeType":"616","endLine":19,"endColumn":2},{"ruleId":"614","severity":1,"message":"615","line":6,"column":1,"nodeType":"616","endLine":19,"endColumn":2},{"ruleId":"652","severity":1,"message":"685","line":164,"column":13,"nodeType":"636","messageId":"654","endLine":164,"endColumn":17},"jsx-a11y/img-redundant-alt","Redundant alt attribute. Screen-readers already announce `img` tags as an image. You don’t need to use the words `image`, `photo,` or `picture` (or any specified custom words) in the alt prop.","JSXOpeningElement","no-native-reassign",["686"],"no-negated-in-lhs",["687"],"import/no-anonymous-default-export","Unexpected default export of anonymous class","ExportDefaultDeclaration","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","Assign object to a variable before exporting as module default","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","no-new-object","The object literal notation {} is preferrable.","NewExpression","preferLiteral","Expected '===' and instead saw '=='.","no-mixed-operators","Unexpected mix of '>>' and '&'.","unexpectedMixedOperator","no-redeclare","'h' is already defined.","Identifier","redeclared","'p' is already defined.","'to' is already defined.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","Unexpected mix of '&&' and '||'.","LogicalExpression","array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","no-throw-literal","Expected an error object to be thrown.","ThrowStatement","object","no-unused-vars","'lerp' is assigned a value but never used.","unusedVar","'count' is assigned a value but never used.","'b' is defined but never used.","'g' is defined but never used.","'r' is defined but never used.","'w4' is assigned a value but never used.","Array.prototype.map() expects a return value from arrow function.","expectedInside","no-fallthrough","Expected a 'break' statement before 'default'.","SwitchCase","default","no-self-assign","'updatedData.lockScaleToPercentage' is assigned to itself.","MemberExpression","selfAssignment","'isProcessImage' is assigned a value but never used.","'imgWidth' is assigned a value but never used.","'imgHeight' is assigned a value but never used.","'applyByDefault' is assigned a value but never used.","no-eval","eval can be harmful.","CallExpression","no-this-before-super","'this' is not allowed before 'super()'.","ThisExpression","noBeforeSuper","'e' is assigned a value but never used.","no-extend-native","Number prototype is read only, properties should not be added.","AssignmentExpression","'name' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]